# 🏨 hotel-kanri プロジェクト - Cursor AI 統合ルール

**最終更新**: 2025年11月19日  
**バージョン**: 2.5.0（標準テスト分離対応）  
**適用対象**: 全AI（Sun/Luna/Suno/Iza）  
**自動読み込み**: Cursor起動時に自動適用

---

## 🏷️ タグ体系（v2.5.0）

**hotel-kanriプロジェクト専用のタグ体系**

Cursor標準のコマンド（`/edit`, `/new`, `@filename`）との衝突を避けるため、**`>>`記号**を使用します。

### 利用可能なタグ

| タグ | 用途 | 使用例 |
|------|------|--------|
| `>> write` | SSOT新規作成 | `>> write SSOT_SAAS_STAFF_MANAGEMENT` |
| `>> impl` | SSOT実装 | `>> impl SSOT_SAAS_PERMISSION_SYSTEM` |
| `>> fix` | バグ修正 | `>> fix SSOT_SAAS_ORDER_MANAGEMENT 削除エラー` |
| `>> rfv` | SSOT実装検証 | `>> rfv SSOT_SAAS_MENU_MANAGEMENT` |
| `>> next` | 次タスク選択 | `>> next` |
| `>> prmt` | プロンプト作成 | `>> prmt COM-81` |

### タグの動作

- **`>> write`**: 必須ドキュメント読み込み → 既存実装調査（15分） → SSOT作成 → 品質チェック（90点以上）
- **`>> impl`**: SSOT読み込み → 要件ID抽出 → 実装プラン提案 → ユーザー承認 → 実装
- **`>> fix`**: SSOT読み込み → バグ原因調査 → 修正方針提案 → ユーザー承認 → 修正
- **`>> rfv`**: SSOT読み込み → 実装状況確認 → 完了率計算 → ギャップ報告
- **`>> next`**: 進捗確認 → 依存関係分析 → 優先度評価 → 次タスク推奨
- **`>> prmt`**: Planeタスク取得 → タイプ判定 → テンプレート適用 → プロンプト出力（チャット内）

**注意**: 
- タグなしの通常の会話も可能です。タグは明確な指示が必要な時のみ使用してください。
- **`>> prmt`で生成されたプロンプトはファイル化しません**（チャット内でのみ出力）

---

## 🔌 【必須】Plane API接続の標準化（CRITICAL）

**絶対ルール**: Plane APIに接続する際は、必ず標準化されたライブラリを使用する

### 🤖 AIがPlaneデータを取得する際の必須フロー

**重要**: 環境変数ファイル（`.env.mcp`）はgitignoreされているため、直接アクセスできません。
必ず以下のいずれかの方法を使用してください。

#### 方法1: **標準スクリプト経由（最も推奨）** ✅

```bash
# 次のタスク取得（最頻出）
cd /Users/kaneko/hotel-kanri/scripts/plane
node get-next-task.cjs

# 全Issue一覧取得
cd /Users/kaneko/hotel-kanri/scripts/plane
node list-issues-tree.cjs

# Issue詳細取得
cd /Users/kaneko/hotel-kanri/scripts/plane
node get-issue-detail.cjs COM-72
```

**理由**:
- ✅ 環境変数を自動ロード（`.env.mcp`から）
- ✅ 認証ヘッダー自動設定（`x-api-key`）
- ✅ エンドポイント形式自動補完
- ✅ エラーハンドリング組込み

#### 方法2: **標準ライブラリ経由（プログラム内）**

```javascript
const planeApi = require('./lib/plane-api-client.cjs');

// Issue取得
const issue = await planeApi.getIssue(issueId);

// Issue更新
const updated = await planeApi.updateIssue(issueId, {
  description: '新しい説明'
});
```

**場所**: `/Users/kaneko/hotel-kanri/scripts/plane/lib/plane-api-client.cjs`

### ❌ 絶対禁止パターン

**以下のパターンは401エラー・404エラーの原因となります**

```javascript
// ❌ 禁止1: .env.mcpを直接読もうとする
const fs = require('fs');
const env = fs.readFileSync('.env.mcp', 'utf8');  // ❌ gitignoreされている

// ❌ 禁止2: Authorization: Bearer ヘッダーの使用
const headers = {
  'Authorization': `Bearer ${apiKey}`  // ❌ 401エラーの原因（x-api-keyを使う）
};

// ❌ 禁止3: 直接のhttpsリクエスト（標準ライブラリを使わない）
const https = require('https');
const req = https.request(url, { headers: { 'x-api-key': key } });  // ❌ 環境変数未ロード

// ❌ 禁止4: 間違ったエンドポイント形式
const url = `${host}/api/issues/${issueId}/`;  // ❌ 404エラーの原因
const url = `${host}/api/v1/issues/${issueId}/`;  // ❌ workspaceとproject ID不足

// ❌ 禁止5: gh CLIやcurlで直接Plane APIを叩く
// curl でPlane APIを直接叩こうとする  // ❌ 認証情報がない
```

### ✅ 正しい実装

```javascript
// ✅ 標準ライブラリを使用
const planeApi = require('./lib/plane-api-client.cjs');

// ✅ Issue取得
const issue = await planeApi.getIssue(issueId);

// ✅ Issue更新
const updated = await planeApi.updateIssue(issueId, {
  description: '新しい説明'
});

// ✅ カスタムリクエスト
const result = await planeApi.request('PATCH', 
  `/api/v1/workspaces/co/projects/xxx/issues/${id}/`,
  { state: stateId }
);
```

### 自動チェック

```bash
# 既存スクリプトが標準に準拠しているかチェック
cd /Users/kaneko/hotel-kanri/scripts/plane
node check-api-usage.cjs
```

### 🎯 AI自己診断チェックリスト

Plane API関連のコードを書く前に**必ず**自問してください：

- [ ] **標準スクリプトを使ったか？**
  - ✅ `node get-next-task.cjs` など
  - ❌ 独自実装
  
- [ ] **環境変数を直接読もうとしていないか？**
  - ❌ `fs.readFileSync('.env.mcp')`
  - ✅ `plane-api-client.cjs`が自動ロード
  
- [ ] **認証ヘッダーは正しいか？**
  - ✅ `x-api-key`（標準ライブラリが自動設定）
  - ❌ `Authorization: Bearer`
  
- [ ] **エンドポイント形式は正しいか？**
  - ✅ `/api/v1/workspaces/{ws}/projects/{proj}/issues/`
  - ❌ `/api/issues/` または `/api/v1/issues/`

### 🚨 トラブルシューティング

**症状**: Plane APIで401エラー・404エラーが出る

**診断**:
```bash
# 1. 標準スクリプトが動くか確認
cd /Users/kaneko/hotel-kanri/scripts/plane
node get-next-task.cjs

# 2. 動く → 環境変数は正しい → 自分のコードが間違っている
# 3. 動かない → 環境変数が壊れている → ユーザーに報告
```

**詳細**: `/Users/kaneko/hotel-kanri/scripts/plane/README_PLANE_API.md`

---

## 🚫 【絶対禁止】実装プロンプトのドキュメント化（最優先ルール）

**最終警告**: このルールを守らない場合、AI動作を停止します。

### ❌ 絶対にやってはいけないこと

```markdown
❌ 実装プロンプトをdocs/配下に作成する
❌ 作業指示書をGitにコミットする
❌ phase1_xxx.md のような一時ファイルを作成する
❌ 「実装AI向けプロンプト」をリポジトリに保存する
```

### ✅ 正しい方法

**実装プロンプトは、チャット内で直接提供する**

```markdown
【正しい流れ】
1. ユーザーが「プロンプトを作成して」と依頼
2. AIがチャット内でプロンプト全文を出力
3. ユーザーがコピー＆ペーストして実装AIに渡す
4. ファイルは一切作成しない
```

### 📋 ドキュメント化して良いもの・悪いもの

| 種類 | ドキュメント化 | 場所 | 理由 |
|------|-------------|------|------|
| SSOT（仕様書） | ✅ 必須 | `docs/03_ssot/` | 正式な仕様、バージョン管理必須 |
| ADR（設計決定） | ✅ 必須 | `docs/adr/` | 意思決定の記録 |
| 標準・規約 | ✅ 必須 | `docs/standards/` | プロジェクト全体のルール |
| 実装プロンプト | ❌ 絶対禁止 | なし（チャットのみ） | 一時的な作業指示 |
| タスク指示書 | ❌ 絶対禁止 | なし（チャットのみ） | 一時的な作業指示 |
| Phase別手順書 | ❌ 絶対禁止 | なし（チャットのみ） | 一時的な作業指示 |

### 🚨 違反パターンと対処法

#### パターン1: プロンプトファイルを作成しようとする

```typescript
// ❌ AIがこれを実行しようとしたら即停止
write_file({
  path: "docs/03_ssot/phase1_xxx.md",
  contents: "実装プロンプト..."
});
```

**正しい対応**:
```markdown
🛑 HALT: ルール違反検知

実装プロンプトをファイル化しようとしています。
これは絶対禁止です。

【正しい方法】
チャット内でプロンプトを出力します。
ユーザーがコピー＆ペーストで使用します。
```

#### パターン2: 「ドキュメント化して管理する必要がある」と提案

**正しい対応**:
```markdown
❌ 間違い: 「プロンプトをドキュメント化しましょう」
✅ 正しい: 「チャット内でプロンプトを出力します」
```

### 💡 なぜこのルールが必要か？

1. **リポジトリの肥大化防止**
   - 一時的なファイルがどんどん蓄積される
   - Git履歴が汚れる

2. **混乱の防止**
   - 「これは正式なSSOTか？作業指示か？」が不明瞭
   - 将来見返したときに混乱

3. **ドキュメント管理の簡素化**
   - docs/配下は「正式な仕様・決定」のみ
   - 一時的なものは含めない

### 🎯 自己診断チェックリスト

プロンプト作成前に、必ず以下を確認：

- [ ] **これは正式なSSOTか？** 
  - YES → `docs/03_ssot/`に作成
  - NO → チャット内で出力
  
- [ ] **これは意思決定の記録か？**
  - YES → `docs/adr/`に作成
  - NO → チャット内で出力

- [ ] **これは一時的な作業指示か？**
  - YES → チャット内で出力（ファイル作成禁止）
  - NO → 上記いずれかに該当

- [ ] **ファイル名に`phase`、`task`、`prompt`が含まれるか？**
  - YES → 絶対にファイル作成してはいけない
  - NO → 上記チェックに従う

### ⚡ 違反時の対処

AIがこのルールを違反した場合：

```markdown
🚨 緊急停止

ルール違反を検知しました。
実装プロンプトをファイル化しようとしています。

【即座に実行】
1. ファイル作成を中止
2. ユーザーに謝罪
3. チャット内でプロンプトを出力

【ユーザーへの報告】
"申し訳ありません。ルールに違反してファイル化しようとしました。
チャット内でプロンプトを出力します。"
```

---

## 🌏 【最優先】グローバル展開戦略

**このシステム群の開発方針として、以下を常に念頭に置いてください：**

### 🎯 市場戦略
- **主要市場**: 日本・アジア・東南アジア圏を中心に展開
- **インバウンド対応**: 中国・インド・東南アジア・アフリカ圏からの旅行客に本格対応
- **差別化**: 表面的な欧米対応ではなく、言語・文化・食事・生活習慣への深い理解に基づく「日本のおもてなし」の実現

### 🌐 技術的対応
1. **15言語完全対応**
   - 中国語（簡体字・繁体字）、韓国語、タイ語、ベトナム語、インドネシア語、マレー語、フィリピン語、ヒンディー語、アラビア語等
   - 単なる翻訳ではなく、文化的ニュアンスを理解した表現

2. **200+国の文化プロファイル**
   - 宗教的配慮（イスラム・ヒンドゥー・仏教・ユダヤ教等）
   - 食文化への深い理解（ハラール・コーシャ・ベジタリアン等）
   - 文化的タブーの回避（数字・色・ジェスチャー等）

3. **文化的に適切なAI応答**
   - コミュニケーションスタイルの最適化
   - 敬語レベルの自動調整
   - 文化的コンテキストの理解

### ✅ 全開発者への必須ルール
- ✅ 機能開発時は常にグローバル展開を意識
- ✅ 多言語対応は後付けではなく、最初から組み込む
- ✅ 文化的配慮は特別機能ではなく、標準機能
- ✅ ステレオタイプを避け、個人を尊重
- ✅ 文化データはセンシティブに扱う（深いリサーチ必須）

### 📖 詳細仕様
**必読SSOT**:
- `/Users/kaneko/hotel-kanri/docs/03_ssot/00_foundation/STRATEGIC_VISION_GLOBAL_EXPANSION.md` ★最重要
- `/Users/kaneko/hotel-kanri/docs/03_ssot/00_foundation/SSOT_WORLD_CLASS_UI_DESIGN_PRINCIPLES.md` ★最重要
- `/Users/kaneko/hotel-kanri/docs/03_ssot/00_foundation/SSOT_MULTILINGUAL_SYSTEM.md`
- `/Users/kaneko/hotel-kanri/docs/03_ssot/00_foundation/SSOT_MULTICULTURAL_AI.md`

---

## 🚨 【緊急停止ルール】エラー発生時の最優先プロトコル

**このセクションは全てのルールより優先されます**

### ⚠️ エラー検知キーワード

以下のキーワードを含むエラーが発生した場合、**即座に実装を停止**してください：

```
- "Error"、"エラー"、"失敗"、"できない"、"できません"
- "Connection refused"、"接続できない"、"Cannot connect"
- "undefined"、"null"、"is not defined"
- "Prisma"、"Database"、"PostgreSQL"、"SQLite"
- "Authentication failed"、"認証失敗"、"Unauthorized"
- "tenant_id"、"テナントID"、"session"
```

### 🛑 エラー発生時の強制手順（絶対遵守）

```markdown
Step 1: 【実装即座停止】
  ❌ エラーを修正しようとしない
  ❌ 推測で実装を続けない
  ❌ 「動けばいい」という発想
  ✅ すぐにStep 2へ

Step 2: 【SSOT再読み込み】
  該当SSOTファイルを必ず再読み込み:
  - テナント関連 → SSOT_SAAS_MULTITENANT.md
  - 認証・セッション → SSOT_SAAS_ADMIN_AUTHENTICATION.md
  - DB・Prisma → SSOT_DATABASE_SCHEMA.md
  - 本番同等性 → SSOT_PRODUCTION_PARITY_RULES.md

Step 3: 【ガードレール確認】
  📖 .cursor/prompts/ssot_implementation_guard.md

Step 4: 【ユーザー報告】
  以下のテンプレートで報告:
  
  🚨 エラーが発生しました。SSOT確認プロトコルを実行します。
  
  ## エラー内容
  [エラーメッセージ]
  
  ## 該当SSOT
  [SSOTファイル名]
  
  ## SSOT記載内容
  [該当セクションの引用]
  
  ## 判断
  - [ ] SSOTに記載あり → SSOT通りに実装
  - [ ] SSOTに記載なし → ユーザーに質問
  
  ## 提案する対応方針
  [具体的な実装方針]
  
  実装を再開してよろしいでしょうか？

Step 5: 【承認後再開】
  ユーザーの承認を得てから実装を再開
```

### 🚫 絶対禁止パターン（自動停止トリガー）

以下のコードパターンを実装しようとした場合、**即座に停止**してSSOT確認：

```typescript
// ❌ Pattern 1: hotel-saasでのPrisma直接使用
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();

// ❌ Pattern 2: フォールバック値の使用
const tenantId = session.tenantId || 'default';
const tenantId = session.tenantId ?? 'default';

// ❌ Pattern 3: 環境分岐実装
if (process.env.NODE_ENV === 'development') {
  // 開発環境専用の実装
}

// ❌ Pattern 4: データベース切り替え提案
"開発環境ではSQLiteを使用すべきです"
"PostgreSQLからSQLiteに切り替えます"

// ❌ Pattern 5: システム境界違反
// hotel-saasから直接DB操作、Prisma実行等
```

**これらのパターンを検知したら、必ずSSOT確認してください。**

---

## 📍 ドキュメント参照ルール（コンテキスト別）- **CRITICAL**

### 現在の作業場所を確認

実装開始前に、必ず以下を確認してください：

```bash
pwd  # 現在のディレクトリを確認
```

### 🏗️ hotel-kanriでの作業（SSOT作成・管理）

**判定**: `/Users/kaneko/hotel-kanri`

✅ **参照可能**:
- `/Users/kaneko/hotel-kanri/docs/_archived_system_docs/` - 全システムのアーカイブ（SSOT作成時のみ）
- `/Users/kaneko/hotel-saas/server/` - 実装ソース
- `/Users/kaneko/hotel-saas/pages/` - 実装ソース
- `/Users/kaneko/hotel-pms/server/` - 実装ソース
- `/Users/kaneko/hotel-member/src/` - 実装ソース
- `/Users/kaneko/hotel-common/src/` - 実装ソース
- `/Users/kaneko/hotel-kanri/docs/03_ssot/` - 既存SSOT
- `/Users/kaneko/hotel-kanri/docs/standards/` - 標準・規約

**目的**: 既存情報を正確に把握し、高品質なSSOTを作成

**許可される行動**:
- 既存ドキュメントの参照（アーカイブ含む）
- 実装ソースの調査
- SSOT間の整合性確認

---

### 🏨 各システムでの作業（SSOT実装）

#### hotel-saasでの作業時

**判定**: `/Users/kaneko/hotel-saas`

✅ **参照必須**:
- `/Users/kaneko/hotel-kanri/docs/03_ssot/` - **SSOTのみ**
- `/Users/kaneko/hotel-saas/server/` - 自システムの実装ソース
- `/Users/kaneko/hotel-saas/pages/` - 自システムの実装ソース
- `/Users/kaneko/hotel-kanri/docs/standards/` - 標準・規約
- `/Users/kaneko/hotel-kanri/.cursor/prompts/` - 実装ガイド

❌ **参照絶対禁止**:
- `/Users/kaneko/hotel-saas/docs/` - **削除済み**
- `/Users/kaneko/hotel-kanri/docs/_archived_system_docs/hotel-saas/` - **アーカイブ**
- 古いドキュメント全般

**理由**: 古いドキュメントを参照すると、SSOT違反実装になる

#### hotel-pmsでの作業時

**判定**: `/Users/kaneko/hotel-pms`

✅ **参照必須**:
- `/Users/kaneko/hotel-kanri/docs/03_ssot/` - **SSOTのみ**
- `/Users/kaneko/hotel-pms/server/` - 自システムの実装ソース

❌ **参照絶対禁止**:
- `/Users/kaneko/hotel-pms/docs/` - **削除予定**
- `/Users/kaneko/hotel-kanri/docs/_archived_system_docs/hotel-pms/` - **アーカイブ**

#### hotel-memberでの作業時

**判定**: `/Users/kaneko/hotel-member`

✅ **参照必須**:
- `/Users/kaneko/hotel-kanri/docs/03_ssot/` - **SSOTのみ**
- `/Users/kaneko/hotel-member/src/` - 自システムの実装ソース

❌ **参照絶対禁止**:
- `/Users/kaneko/hotel-member/docs/` - **削除予定**
- `/Users/kaneko/hotel-kanri/docs/_archived_system_docs/hotel-member/` - **アーカイブ**

#### hotel-commonでの作業時

**判定**: `/Users/kaneko/hotel-common`

✅ **参照必須**:
- `/Users/kaneko/hotel-kanri/docs/03_ssot/` - **SSOTのみ**
- `/Users/kaneko/hotel-common/src/` - 自システムの実装ソース

❌ **参照絶対禁止**:
- `/Users/kaneko/hotel-common/docs/` - **削除予定**
- `/Users/kaneko/hotel-kanri/docs/_archived_system_docs/hotel-common/` - **アーカイブ**

---

### 🚨 エラー発生時のドキュメント参照判定

エラーが発生した時の対応フロー：

```
Step 1: 現在地確認
  pwd を実行
  ↓
Step 2: コンテキスト判定
  ↓
  hotel-kanri？
    ↓ YES
    ✅ アーカイブ参照OK（SSOT作成時のみ）
    ✅ 既存ドキュメント参照OK
    ✅ 問題解決のために必要な情報を収集
  ↓ NO
  各システム？
    ↓ YES
    ❌ システム内ドキュメント参照NG（削除済み）
    ❌ アーカイブ参照NG
    ✅ SSOTのみ参照
    ✅ error_detection_protocol.md 実行
    ✅ SSOT確認
    ✅ ユーザーに報告
```

### 🤖 AI自己診断チェックリスト

実装開始前に、以下を**必ず**自問してください：

- [ ] **現在の作業ディレクトリは？** (`pwd`で確認)
- [ ] **hotel-kanriで作業中？** → アーカイブ参照OK
- [ ] **各システムで作業中？** → SSOTのみ参照、アーカイブNG
- [ ] **エラー発生時？** → コンテキスト判定 → 適切な参照先を選択

---

<!-- OPS:BEGIN progress (auto-generated) -->
## 📊 【進捗運用ルール】唯一の真実（canonical）

**制定日**: 2025年10月21日  
**ポリシー**: OPS-101 進捗管理ポリシー  
**設定**: ops/policy.yml  

### 🎯 基本原則

**File が唯一の進捗管理ツール**

✅ **Fileでやること**:
- タスクの作成・更新
- ステータス管理（Backlog → In Progress → Done）
- 工数記録（見積もり + 実績）
- 依存関係管理・ブロッカー管理
- ラベル管理（SSOT作成/実装/バージョンアップ）
- 担当者アサイン（Sun/Luna/Suno/Iza）

❌ **やらないこと**:
- 他のファイルでの進捗管理
- ツール（Plane/Linear）との併用

📊 **進捗ファイル**: `docs/03_ssot/SSOT_PROGRESS_MASTER.md`

### 🎯 タスク選択ルール（★★★AI必読）

**絶対ルール**: タスクを開始する前に、必ず標準スクリプトで次のタスクを取得する

#### 標準タスク取得フロー（必須）

```bash
cd /Users/kaneko/hotel-kanri/scripts/plane
node get-next-task.cjs
```

**このスクリプトが自動的に以下を実施**:
1. ✅ Planeから全Issuesを取得
2. ✅ State = "Backlog"のみ抽出
3. ✅ 依存関係チェック（Blocked byなし）
4. ✅ Phase順 → sequence_id昇順でソート
5. ✅ 次の推奨タスクを表示

#### タスク選択基準（自動適用）

```markdown
Priority 1（Phase順）: 
  Phase 1 → Phase 2 → Phase 3 → Phase 4
  
Priority 2（sequence_id順）: 
  同じPhase内では番号が小さい順
  
Priority 3（依存関係）: 
  Blocked byがないタスクのみ
  
Priority 4（State）: 
  Backlogのみ
```

#### タスク選択の禁止事項

❌ 絶対禁止:
- 標準スクリプトを使わずに手動でタスクを選択
- 依存関係を無視してタスクを開始する
- Phase順を無視してタスクを選択する
- Backlog以外のStateのタスクを選択する

✅ 正しい対応:
1. `node get-next-task.cjs` を実行
2. 表示された推奨タスクをユーザーに報告
3. ユーザーの承認を得てから開始
4. タスクをIn Progressに更新

#### よくあるミス

❌ 間違い: 「Phase 2のタスクがあるから、適当にCOM-105から始めよう」
✅ 正しい: 「`get-next-task.cjs`を実行 → COM-72が推奨された → ユーザーに報告」

❌ 間違い: 「前回COM-66だったから、次はCOM-67だろう」
✅ 正しい: 「`get-next-task.cjs`を実行 → 最新のBacklogを確認」
```

**詳細**: ops/OPS-101-Progress.md

<!-- OPS:END progress -->

## 📖 用語体系: Phase vs Item/Step

**制定日**: 2025年11月7日  
**バージョン**: 1.0.0  

**絶対ルール**: 用語の混同を防ぐため、以下を厳守すること

### Phase（フェーズ）- プロジェクト全体でのみ使用

- **使用場所**: Plane Issue、ロードマップ、マイルストーン
- **例**: `[Phase 2] テナント管理実装`
- **意味**: プロジェクト全体の段階（Phase 1: 基盤設計、Phase 2: 基盤機能実装、等）

### Item + Step - タスク内の実装手順でのみ使用

- **使用場所**: 実装プロンプト、作業手順書、チェックリスト
- **構造**:
  ```
  Item 1: 事前調査
    ├ Step 1: SSOT確認
    ├ Step 2: 既存実装調査
    └ Step 3: スコープ判定
  Item 2: DB実装
    ├ Step 1: Prismaスキーマ確認
    └ Step 2: マイグレーション作成
  ...
  ```

**詳細**: `/Users/kaneko/hotel-kanri/docs/standards/TERMINOLOGY_PHASE_VS_ITEM_STEP.md`

## 📊 【Linear運用ルール】進捗管理の唯一の真実

**導入日**: 2025年10月18日  
**対象**: 全AI（Sun/Luna/Suno/Iza）

### 🎯 基本原則

**Linearが唯一の進捗管理ツール**

✅ **Linearでやること**:
- タスクの作成・更新
- ステータス管理（Todo → In Progress → Done）
- 工数記録（見積もり + 実績）
- 依存関係管理・ブロッカー管理

❌ **やらないこと**:
- SSOT_PROGRESS_MASTER.md の手動更新
- Markdownファイルでの進捗管理

### 🎯 次のタスク選択ルール（★★★AI必読）

**絶対ルール**: タスクを開始する前に、以下の順序で選択する

```markdown
【タスク選択の優先順位】

Priority 1（最優先）: 
  1. Status = "Backlog" または "Spec Ready"
  2. Priority = 1（最高優先度）
  3. 依存関係 = ブロックされていない（Blocked byなし）
  4. Assignee = 自分（Sun/Luna/Suno/Iza）
  
Priority 2（高優先）:
  1. Status = "Backlog" または "Spec Ready"
  2. Priority = 2
  3. 依存関係 = ブロックされていない
  
Priority 3（通常）:
  1. Status = "Backlog"
  2. Priority = 3
  3. 依存関係 = ブロックされていない

【タスク選択の禁止事項】

❌ 絶対禁止:
- 依存関係を無視してタスクを開始する
- 「Blocked by」が設定されているタスクを開始する
- 自分（Assignee）以外のタスクを開始する
- Priorityを無視してタスクを選択する

✅ 正しい対応:
1. Linearで次のタスクを検索
2. 依存関係を確認
3. ブロックされていないタスクを選択
4. ユーザーに「次のタスク: LIN-XXX」を報告
5. ユーザーの承認を得てから開始

【依存関係の理解】

SSOT作成 → hotel-common実装 → hotel-saas実装

例:
- LIN-1: SSOT作成: SSOT_ADMIN_PERMISSIONS
- LIN-2: hotel-common実装: SSOT_ADMIN_PERMISSIONS (Blocked by LIN-1)
- LIN-3: hotel-saas実装: SSOT_ADMIN_PERMISSIONS (Blocked by LIN-2)

正しい順序:
1. LIN-1を完了
2. LIN-2を開始（LIN-1完了後）
3. LIN-3を開始（LIN-2完了後）

間違った順序:
❌ LIN-1未完了でLIN-2を開始
❌ LIN-2未完了でLIN-3を開始
```

### 🔄 ロードマップ修正フロー（Cursor主導 + Linear実行）

```markdown
Step 1: AIが検知（Cursor）
  └─ 例: 依存関係の問題、新規タスク必要

Step 2: ユーザーに提案（Cursor）
  └─ 理由・影響範囲・工数変化を明示

Step 3: ユーザー承認
  └─ 「承認します」または「却下」

Step 4: Linear自動更新（Linear API）
  ├─ タスク作成/更新
  ├─ 依存関係設定
  ├─ 担当者アサイン
  └─ チームに通知

Step 5: ドキュメント記録（Git）
  └─ 週次エクスポート（Linear → Markdown）
```

### ❌ 絶対禁止事項

**ユーザー承認なしの変更**:
- ❌ タスクの追加・削除
- ❌ 優先度・依存関係の変更
- ❌ Phase構成の変更

**承認不要な操作**:
- ✅ ステータス変更（Todo → In Progress → Done）
- ✅ コメント追加
- ✅ 工数実績記録

**詳細**: `/Users/kaneko/hotel-kanri/docs/03_ssot/00_foundation/LINEAR_SETUP_GUIDE.md`

---

## 🚨 【最優先】実装中断の基準（Implementation Halt Protocol）★★★CRITICAL

**絶対ルール**: 以下の場合、実装を即座に停止してユーザー（管理AI）に報告する

### 必須停止トリガー（Layer 1）- 絶対に停止

1. **SSOT照合失敗（0件）** or **SSOT複数一致**
   - grep -nE でSSO**T**定義を検索したが0件、または2件以上
   - 対応: テンプレート1で報告
   - >> prmt連携: プロンプト生成時にSSOT照合を実施、0件/複数一致で中断

2. **ルーティング不一致**
   - `/api/v1/admin` 形式外
   - 深いネスト（`/api/v1/admin/[親]/[id]/[子]/[id]`）
   - 二重`/api`（`/api/api/`）
   - A/B方式混在（hotel-common）
   - B方式違反（hotel-common: routerで絶対パス）
   - `index.*`ファイル（hotel-saas）
   - `$fetch`直でCookie未転送（hotel-saas）
   - Set-Cookie透過未実装（hotel-saas）
   - auth/healthが保護下（sessionAuthMiddleware後に登録）
   - 旧プロセス起動検知（ポート占有/EADDRINUSE）
   - 対応: ルーティング特化報告

3. **システム境界違反**
   - hotel-commonにNitro構成（`server/api/`）存在
   - hotel-saasでPrisma直接使用
   - hotel-saasで`$fetch`直使用（Cookie未転送）
   - 対応: テンプレート1で報告

4. **依存ファイル非実在・未生成**
   - プロンプトで参照されているファイルが不在
   - 対応: テンプレート1で報告

5. **型エラー連鎖（>5件/1ステップ）**
   - TypeScript型チェックで5件以上のエラー
   - 条件: "型定義不明"が起点
   - 対応: テンプレート1で報告

6. **Prismaスキーマ変更・直接SQL**
   - モデル/列の追加・削除・型変更
   - マイグレーション作成
   - 直接SQL実行
   - 対応: テンプレート1で報告、SSOT_DATABASE_MIGRATION_OPERATION.md準拠確認

7. **tenant_idフォールバック/環境分岐**
   - `|| 'default'` / `?? 'default'`
   - `if (process.env.NODE_ENV === 'development')`
   - 対応: テンプレート1で報告、SSOT違反

8. **矛盾の発見**
   - プロンプト vs SSOT
   - 既存実装 vs SSOT
   - 対応: テンプレート1で報告

9. **エラー原因不明**
   - 標準的なトラブルシューティングで解決不可
   - 15分以上調査しても進展なし
   - 対応: テンプレート1で報告、試したコマンド/結果/仮説を含める

### 推奨停止トリガー（Layer 2）- 判断推奨

1. **セキュリティ・テナント分離・CORS判断**
2. **パフォーマンス影響**（1000件以上一括取得、N+1クエリ）
3. **UI/UX判断**
4. **既存実装整合性**

### 進捗報告トリガー（Layer 3）- 必ず報告

1. **Item完了時**
2. **大規模変更前**（3ファイル以上、100行以上変更）
3. **タイムアウト停止**（15分以上進展なし）

### 停止のノイズ対策

- ✅ 1 Itemあたり同一事象での停止は1回まで
- ✅ タイムアウト停止: 15分ルール
- ✅ 明示的OK例（停止不要）: Lint修正、型注釈追加、ログ出力調整、README軽微修正、テストExpectation調整

### 停止時の対応

1. 実装を停止
2. 該当するテンプレート（1/2/3）で報告
3. ユーザーの指示を待つ
4. **推測で実装を続けない**

### 自己診断チェックリスト（各Step開始前）

- [ ] これはSSO**T**定義に記載されているか？
- [ ] これは複数の実装方法があるか？
- [ ] これは矛盾していないか？
- [ ] これはエラーの原因が明確か？
- [ ] 依存ファイルは実在するか？
- [ ] これはセキュリティ/パフォーマンスに影響するか？

**詳細**: `/Users/kaneko/hotel-kanri/.cursor/prompts/implementation_halt_protocol.md`

---

## 🎯 基本原則（最優先）

### 0. QOS v1（Quality Operating System）準拠 ★★★NEW

**hotel-kanriは QOS v1 準拠の開発体制を採用しています**

#### **QOS v1 の3つの柱**

1. **Docs-as-Code**: 全ての設計・仕様を文書化（SSOT/ADR/QAS）
2. **トレーサビリティ**: 要求 → 設計 → 実装 → テストの追跡
3. **品質の定量化**: 自動チェック + スコア算出

#### **必須参照ドキュメント**

**設計・意思決定**:
- `/Users/kaneko/hotel-kanri/docs/adr/README.md` - ADR（Architecture Decision Records）
- `/Users/kaneko/hotel-kanri/docs/03_ssot/00_foundation/NFR-QAS.md` - QAS（Quality Attribute Scenarios / ISO 25010）

**セキュリティ**:
- `/Users/kaneko/hotel-kanri/docs/security/OWASP-ASVS-L2-CHECKLIST.md` - OWASP ASVS Level 2準拠

**トレーサビリティ**:
- `/Users/kaneko/hotel-kanri/docs/traceability-matrix.md` - 要件追跡マトリクス（自動生成）

#### **自動チェックツール**

```bash
# SSOT間整合性チェック
node scripts/quality/check-ssot-consistency.cjs

# データベース命名規則チェック
node scripts/quality/check-database-naming.cjs

# トレーサビリティマトリクス生成
node scripts/quality/generate-traceability-matrix.cjs
```

#### **新規機能開発時の必須フロー**

```
Step 1: 要求定義（SSOT + 要件ID）
  ↓
Step 2: 技術決定（ADR作成）← ★ 重要な決定は必ず記録
  ↓
Step 3: 非機能要件（QAS定義）← ★ 性能・セキュリティ等
  ↓
Step 4: 設計（API/DB設計）
  ↓
Step 5: 実装（コード内に要件IDコメント）
  ↓
Step 6: テスト（Accept検証）
  ↓
Step 7: トレーサビリティ確認（自動生成マトリクス）
```

---

### 1. 実装前の強制チェックリスト（★★★絶対遵守）

**絶対ルール**: 実装を開始する前に**必ず**以下をチェックする

**必須参照ドキュメント**: `/Users/kaneko/hotel-kanri/.cursor/prompts/implement_from_ssot.md` 

このドキュメントは`write_new_ssot.md`と同等の品質管理を実装時に適用するためのものです。

```markdown
【実装開始前の強制チェックリスト】

✅ Phase 1: 該当SSOTの読み込み（必須）
  - [ ] SSOTファイルを開いた
  - [ ] SSOTを最後まで読んだ
  - [ ] 「[SSOTファイル名] 読了」と表示した
  - [ ] 要件IDを全て抽出した（XXX-nnn形式）
  - [ ] Accept（合格条件）を全て抽出した
  
  🚨 SSOT未読の場合は実装を開始しない
  
✅ Phase 2: 既存実装の100%調査（必須・15分）
  - [ ] 同じディレクトリの既存ファイル3つ以上確認
  - [ ] データベーステーブル確認（Prismaスキーマ）
  - [ ] 関連SSOTの確認
  - [ ] システム間連携の確認
  - [ ] 命名規則・パターン・認証方式を把握
  
  🚨 既存実装未確認の場合は実装を開始しない

✅ Phase 2.5: ★NEW 実装状況の完全スキャン（必須・5分）
  
  **絶対ルール**: タスク関連の全実装状況を確認する（Untracked filesだけでは不十分）
  
  **Step 1: 関連キーワード抽出**
  - [ ] タスクタイトルからキーワード抽出（例: "テナント管理" → tenant, room-grade等）
  - [ ] SSOTから関連キーワード抽出
  - [ ] 既存実装から推測されるキーワード抽出
  
  **Step 2: 実装状況の完全スキャン（必須コマンド4種）**
  ```bash
  # 1. Untracked files確認
  git status
  
  # 2. Git管理下の全ファイル確認
  git ls-files server/api/v1/admin/ src/routes/ | grep -i '<keyword>'
  
  # 3. コミット履歴確認
  git log --all --oneline --name-only -- server/api/v1/admin/ src/routes/ | grep -i '<keyword>'
  
  # 4. 直近PRマージ済み確認
  gh pr list --state merged --search '<keyword>' | head -10
  ```
  
  **Step 3: 実装状況サマリー作成**
  - [ ] hotel-common側: ✅ 実装済み / ❌ 未実装
  - [ ] hotel-saas側: ✅ 実装済み / ❌ 未実装
  - [ ] マージ状態: ✅ マージ済み / ❌ 未マージ / ⚠️ Untracked
  
  **Step 4: ユーザーにスコープ確認**
  - [ ] 実装済み項目を明示
  - [ ] 未実装項目を明示
  - [ ] スコープが不明確な場合は実装中断 → ユーザーに確認
  
  🚨 実装状況スキャン未実施の場合は実装を開始しない
  
  **禁止パターン**:
  - ❌ Untracked filesのみで判断（Git管理下を見落とす）
  - ❌ コミット履歴・PR履歴を確認しない
  - ❌ スコープを推測で決め打ち（ユーザー確認なし）
  - ❌ 関連キーワードの網羅スキャン未実施

✅ Phase 3: ハルシネーション防止チェック（必須）
  - [ ] 参照する全てのファイルが実在することを確認
  - [ ] プレースホルダーを使用していない
  - [ ] 曖昧表現を使用していない（「たぶん」「おそらく」等）
  - [ ] 確認済みと嘘をついていない
  
  🚨 不確実な情報で実装を開始しない

✅ Phase 4: 実装プラン提案（必須）
  - [ ] 実装対象の明確化（ファイル一覧・役割）
  - [ ] 実装順序の提案
  - [ ] 工数見積もり
  - [ ] 実装方針の説明（SSOT準拠の根拠）
  - [ ] ユーザーの承認を得た
  
  🚨 承認なしで実装を開始しない

✅ Phase 5: 実装時の必須ルール
  - [ ] SSOT準拠の徹底（要件ID全実装、Accept全達成）
  - [ ] 命名規則の厳守（DATABASE_NAMING_STANDARD, API_ROUTING_GUIDELINES）
  - [ ] エラーハンドリングの統一
  - [ ] 認証・セキュリティの徹底
  - [ ] テストの実装（APIテスト、手動UIテスト）

✅ Phase 6: 実装後の必須確認
  - [ ] 要件ID完全実装チェック
  - [ ] テスト実施・結果確認
  - [ ] SSOT準拠チェック
  - [ ] ドキュメント更新

❌ 絶対禁止:
- Phase 1-6を飛ばして実装を開始する
- SSOTを読まずに「想像」で実装する
- 既存実装を確認せずに実装する
- 実在しないファイルを参照する
- ユーザーの承認なしで実装する
- SSOT記載外の機能を勝手に追加する

📋 品質スコア目標: 90点以上 / 100点満点
```

### 2. 実装前の相談・合意プロセス [[memory:4821787]]

**絶対ルール**: 実装を開始する前に**必ず**計画を相談・合意する

```markdown
実装開始前の必須ステップ:
1. 📋 要件の理解と確認
2. 💭 実装方針の提案
3. ⏸️  ユーザーの承認待ち
4. ✅ 承認後に実装開始
5. 📊 結果の報告

❌ 絶対禁止:
- いきなり実装を開始する
- 「たぶんこうだろう」で進める
- 承認なしでコードを書く
```

### 2. ドキュメント絶対遵守

**絶対ルール**: ドキュメントに反する実装は一切しない

```markdown
必須確認ドキュメント:
1. 📖 SSOT（Single Source of Truth）
2. 📐 設計書・仕様書
3. 🎯 アーキテクチャドキュメント
4. 🚨 制約・禁止事項

❌ 絶対禁止:
- ドキュメントを読まずに実装
- 「想像」「推測」で実装
- 仕様書にない機能を勝手に実装
```

### 3. ハルシネーション（幻覚）の防止（★★★強化版）

**絶対ルール**: 全てのファイル・関数・変数は実在確認必須

```markdown
【ハルシネーション検出システム】

🚨 実装前の強制チェック:
  1. ファイル存在確認
     - read_file または list_dir で実在確認
     - 確認せずに「存在します」と言わない
     
  2. プレースホルダー使用禁止
     ❌ import { SomeType } from '@/types' // プレースホルダー
     ❌ const data = await fetchData() // 想像上の関数
     ✅ 実際に存在する関数・型のみ使用
     
  3. 曖昧表現の禁止
     ❌ 「たぶん〜だと思います」
     ❌ 「おそらく〜でしょう」
     ❌ 「〜かもしれません」
     ✅ 「確認します」「調査します」
     
  4. 確認済みと嘘をつかない
     ❌ 「既に確認しました」（確認していない）
     ❌ 「問題ありません」（確認していない）
     ✅ 「今から確認します」

❌ 絶対禁止パターン:
- 実在しないファイル・関数・変数を参照する
- 確認していないことを「確認済み」と言う
- 不確実なことを確実と言う
- プレースホルダーを使用する
- 想像で実装する

✅ 正しい対応:
- 不明な点は必ず確認する
- 「確認します」と明示してから確認する
- ファイルの存在を確認してから参照
- 実際に存在するコードのみ使用
```

### 4. 進捗管理の一元化（CRITICAL）

**絶対ルール**: 進捗管理ファイルは1つだけ

```markdown
唯一の進捗管理ファイル:
📊 /Users/kaneko/hotel-kanri/docs/03_ssot/SSOT_PROGRESS_MASTER.md

❌ 絶対禁止:
- 他のファイルで進捗を記録する
- プロンプトファイルに進捗を書く
- README.mdに進捗を書く
- Phase別の進捗ファイルを作る

✅ 正しい対応:
- 進捗は SSOT_PROGRESS_MASTER.md だけに記録
- 他のファイルは SSOT_PROGRESS_MASTER.md を参照する
- 作業開始時・終了時に必ず更新する

詳細ガードレール:
📖 /Users/kaneko/hotel-kanri/.cursor/prompts/progress_management_guardrails.md
```

### 5. 実装状況の管理（CRITICAL）

**絶対ルール**: 実装状況はSSOT内で管理する

```markdown
実装状況の記録場所:
📊 各SSOTファイル内の「実装状況」セクション

❌ 絶対禁止:
- 実装レポートファイルを作成する
- 別ファイルで実装状況を管理する
- 曖昧な判断（「だいたい動いてるから100%」等）

✅ 正しい対応:
- SSOTファイル内の「実装状況」セクションを更新
- バージョンごとに管理
- 完了率を正確に記録（Phase完了数 / 5）
- 100%は5つのPhase全て完了時のみ

実装完了の定義:
- Phase 1: データベース実装完了
- Phase 2: API実装完了
- Phase 3: フロントエンド実装完了
- Phase 4: テスト完了
- Phase 5: SSOT準拠確認

詳細ガードレール:
📖 /Users/kaneko/hotel-kanri/.cursor/prompts/implementation_status_guardrails.md
```

---

## 🚨 SSOT実装強制プロトコル（CRITICAL）

### エラー発生時の自動実行手順

あなたがSSO実装中に**エラーに遭遇した場合**、以下の手順を**必ず**実行してください：

#### ステップ1: 実装を即座に停止 🛑
- ❌ エラーを修正しようとしない
- ❌ 推測で実装を続けない  
- ❌ 「動けばいい」という発想
- ✅ **すぐに次のステップへ**

#### ステップ2: 該当SSOTを読み直す 📖
実装中のSSOTファイルを**必ず再読み込み**してください。

**SSOT一覧**（エラー内容に応じて参照）:
- **テナント関連エラー**: `/Users/kaneko/hotel-kanri/docs/03_ssot/00_foundation/SSOT_SAAS_MULTITENANT.md`
- **認証・セッションエラー**: `/Users/kaneko/hotel-kanri/docs/03_ssot/00_foundation/SSOT_SAAS_ADMIN_AUTHENTICATION.md`
- **DB・Prismaエラー**: `/Users/kaneko/hotel-kanri/docs/03_ssot/00_foundation/SSOT_DATABASE_SCHEMA.md`
- **本番同等性**: `/Users/kaneko/hotel-kanri/docs/03_ssot/00_foundation/SSOT_PRODUCTION_PARITY_RULES.md`

#### ステップ3: ガードレール確認 🛡️
エラーパターン別の対応方法を確認：
📖 `/Users/kaneko/hotel-kanri/.cursor/prompts/ssot_implementation_guard.md`

#### ステップ4: 判断
- **SSOTに記載あり** → SSOT通りに実装
- **SSOTに記載なし** → ユーザーに質問

#### ステップ5: 実装再開
ユーザーの承認を得てから実装を再開

---

## ❌ 絶対禁止パターン（自動検知対象）

以下のパターンを検知した場合、**即座に実装を停止**してSSOTを確認してください：

### 1. hotel-saasでのPrisma直接使用（CRITICAL）
```typescript
// ❌ 検知対象：SSOT違反
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();
const data = await prisma.tenant.findMany();

// 🚨 停止理由：hotel-saasはプロキシ専用、hotel-common経由必須
// 📖 参照SSOT：SSOT_SAAS_MULTITENANT.md
// ✅ 正しい実装：
const data = await $fetch('http://localhost:3400/api/v1/admin/tenants');
```

### 2. フォールバック実装（CRITICAL）
```typescript
// ❌ 検知対象：本番障害リスク
const tenantId = session.tenantId || 'default';
const tenantId = user?.tenantId ?? 'default';

// 🚨 停止理由：本番環境で'default'テナント不在→全機能停止
// 📖 参照SSOT：SSOT_PRODUCTION_PARITY_RULES.md
// ✅ 正しい実装：
const tenantId = session.tenantId;
if (!tenantId) {
  throw new Error('テナントIDが取得できません');
}
```

### 3. 環境分岐実装（CRITICAL）
```typescript
// ❌ 検知対象：本番同等違反
if (process.env.NODE_ENV === 'development') {
  tenantId = 'default';
}

// 🚨 停止理由：開発・本番で実装を変えてはいけない
// 📖 参照SSOT：SSOT_PRODUCTION_PARITY_RULES.md
// ✅ 正しい実装：環境変数で接続先のみ変更、ロジックは同一
```

### 4. システムの境界を越えた実装
```typescript
// ❌ hotel-saasから他システムのDBに直接アクセス
// ❌ hotel-saasでRedisに直接接続（認証以外）
// ❌ hotel-commonのPrisma設定を変更

// ✅ 各システムの役割を厳守：
// - hotel-saas: プロキシ専用
// - hotel-common: API基盤・DB層
```

---

## 🤖 AI自己診断チェックリスト

エラー発生時、以下を**必ず**自問してください：

- [ ] **このエラーの前にSSOTを読み直したか？**
- [ ] **実装しようとしているシステムの役割を理解しているか？**
  - hotel-saas: プロキシ専用（DB直接アクセス禁止）
  - hotel-common: API基盤・DB層（全システムへのAPI提供）
- [ ] **データベース直接アクセスしようとしていないか？**
- [ ] **フォールバック値（'default'、null等）を使おうとしていないか？**
- [ ] **環境分岐（NODE_ENV判定等）を実装しようとしていないか？**

**1つでも「いいえ」がある場合**: 該当SSOT確認必須

---

## 📋 エラー発生時の報告テンプレート

エラーが発生した場合、以下のテンプレートで報告してください：

```markdown
🚨 エラーが発生しました。SSOT確認プロトコルを実行します。

## Step 1: 実装停止
実装を停止しました。

## Step 2: SSOT再確認
該当SSOT: [SSOTファイル名]
確認中...

## Step 3: SSOT記載内容
[該当セクションの引用]

## Step 4: 判断
- [x] SSOTに記載あり
- [ ] SSOTに記載なし

## Step 5: 対応方針
[SSOT準拠の実装方針]

実装を再開してよろしいでしょうか？
```

---

## 🎯 システム別役割（厳守）

### hotel-saas
**役割**: プロキシ（中継）専用

**許可**:
- ✅ hotel-commonのAPIを呼び出す
- ✅ フロントエンド実装（Pages、Composables、ミドルウェア）
- ✅ APIプロキシ実装（`server/api/`配下）

**禁止**:
- ❌ Prismaを直接使用
- ❌ データベースに直接接続
- ❌ Redisに直接接続（認証は例外）
- ❌ hotel-pms/memberのDBに直接アクセス

### hotel-common
**役割**: API基盤・データベースアクセス層

**許可**:
- ✅ Prisma使用
- ✅ PostgreSQLアクセス
- ✅ Redisアクセス
- ✅ 全システムへのAPI提供

**禁止**:
- ❌ フロントエンド実装（Pages等）

---

## 🗄️ データベース操作ルール（CRITICAL）

### 🚨 データベース操作指示の必須ルール（★★★最優先）

**データベース操作（マイグレーション、テーブル作成、データ投入等）を含む指示を作成する場合、必ず以下を遵守すること。**

#### 必須参照SSOT

```markdown
📖 SSOT_DATABASE_MIGRATION_OPERATION.md（★★★必須）
パス: /Users/kaneko/hotel-kanri/docs/03_ssot/00_foundation/SSOT_DATABASE_MIGRATION_OPERATION.md
目的: データベース操作の絶対的なガイドライン
```

#### データベース操作指示の必須構成要素

データベース操作を含む指示には、必ず以下を含めること：

1. **必読ドキュメントセクション**
   - SSOT_DATABASE_MIGRATION_OPERATION.md
   - DATABASE_NAMING_STANDARD.md
   - 該当機能のSSO

2. **絶対禁止セクション**
   - 直接SQL実行の禁止
   - 権限不足時の誤った対応の禁止
   - スキーマドリフト発生パターンの禁止

3. **環境変数確認ステップ**
   - マイグレーション用DATABASE_URL確認（admin権限必須）

4. **Prisma標準手順**
   - スキーマ更新
   - マイグレーション作成・実行
   - 検証（migrate status）

5. **トラブルシューティングセクション**
   - 権限エラー対応
   - スキーマドリフト対応

6. **完了条件**
   - 必須確認項目チェックリスト
   - 報告フォーマット

**詳細ルール**: `/Users/kaneko/hotel-kanri/.cursor/prompts/database_operation_rules.md`

---

### 命名規則（厳守）

```typescript
// ❌ 間違い：camelCaseのカラム名
model Tenant {
  tenantId String // ← 間違い
}

// ✅ 正しい：snake_caseのカラム名 + @map
model Tenant {
  tenantId String @map("tenant_id") // ← 正しい
  @@map("tenants")
}
```

**絶対ルール**:
- ✅ **新規テーブル名**: `snake_case`必須
- ✅ **新規カラム名**: `snake_case`必須
- ✅ **Prismaモデル名**: `PascalCase`
- ✅ **Prismaフィールド名**: `camelCase` + `@map`ディレクティブ必須
- ✅ `@@map`ディレクティブ必須

**参照**:
- 📖 `/Users/kaneko/hotel-kanri/docs/standards/DATABASE_NAMING_STANDARD.md`
- 📖 `/Users/kaneko/hotel-kanri/.cursor/prompts/database_naming_standard_reference.md`
- 📖 `/Users/kaneko/hotel-kanri/.cursor/prompts/database_operation_rules.md`（★★★データベース操作指示ルール）

### マルチテナント必須要件

```typescript
// ❌ 間違い：tenant_idなしクエリ
const orders = await prisma.order.findMany();

// ✅ 正しい：tenant_id必須
const orders = await prisma.order.findMany({
  where: { tenantId: session.tenantId }
});
```

**絶対ルール**:
- ✅ 全クエリに`tenant_id`フィルタ必須
- ✅ マルチテナント分離の厳守
- ❌ `tenant_id`なしクエリは絶対禁止

---

## 🌐 API実装ルール（hotel-common/hotel-saas共通）★★★CRITICAL

### 🚨 API実装開始前の必須チェック（絶対遵守）

**絶対ルール**: APIエンドポイントを実装する前に、必ず以下を確認する

#### Step 1: SSOT定義のエンドポイントパス確認（必須）

```bash
# SSOT定義を検索（HTTPメソッドと正規表現で厳密に）
grep -nE '^(GET|POST|PUT|PATCH|DELETE)\s+/api/v1/admin/' \
  /Users/kaneko/hotel-kanri/docs/01_systems/saas/API_ROUTING_GUIDELINES.md | grep -i [機能名]

# マルチテナントSSOTでも確認
grep -nE '^(GET|POST|PUT|PATCH|DELETE)\s+/api/v1/' \
  /Users/kaneko/hotel-kanri/docs/03_ssot/00_foundation/SSOT_SAAS_MULTITENANT.md | grep -i [機能名]
```

**確認ポイント**:
- ✅ SSOT定義のエンドポイントパスを特定
- ✅ HTTPメソッド（GET/POST/PUT/PATCH/DELETE）を確認
- ✅ パスが `/api/v1/admin/[resource]` 形式か確認
- ❌ 深いネスト（`/api/v1/admin/[親]/[id]/[子]/[id]`）は禁止

#### Step 2: エンドポイントパスの検証（必須）

**SSOT準拠チェックリスト**:
- [ ] SSOT定義を確認したか？
- [ ] エンドポイントパスがSSO**T**定義と完全一致しているか？（SSO→SSOT）
- [ ] ベースパスが `/api/v1/admin/[resource]` 形式か？
- [ ] 深いネスト（禁止）になっていないか？
- [ ] ルーター登録パスがSSO**T**定義と一致しているか？

#### Step 3: ルーター登録方法の決定（システム別）

**hotel-common（Express）**:
```typescript
// B方式（標準）: routerは相対パス、app.use側で絶対パス指定
// ✅ 正しい（二重付与なし）
router.post('/', ...)
app.use('/api/v1/admin/switch-tenant', switchTenantRouter)

// ❌ 禁止（二重付与の原因）
router.post('/api/v1/admin/switch-tenant', ...)
app.use('/api', router)
```

**hotel-saas（Nitro）**:
```typescript
// ファイル名 = エンドポイントパス
// ✅ 正しい
server/api/v1/admin/switch-tenant.post.ts
server/api/v1/admin/tenants.get.ts

// ❌ 禁止（深いネスト）
server/api/v1/admin/tenants/[id]/items/[itemId].get.ts

// ❌ 禁止（index.*ファイル）
server/api/v1/admin/tenants/index.get.ts
```

#### Step 4: 認証Allowlist確認（必須）

**認証不要パス（必ずミドルウェア外または早期return）**:
```typescript
// hotel-common（Express）
const allowlist = [
  '/health',
  '/api/v1/admin/auth/login',
  '/api/v1/admin/auth/logout',
  '/api/v1/admin/auth/refresh'
]

// これらのパスはsessionAuthMiddleware適用前に登録
app.get('/health', ...)
app.use('/api/v1/admin/auth', authRouter)  // 認証系
app.use('/api', sessionAuthMiddleware)     // この後に保護ルート
app.use('/api/v1/admin/tenants', tenantsRouter)
```

#### Step 5: 404ポリシー確認（必須）

**SSOT定義の404ポリシー**:
```typescript
// ✅ 正しい（列挙耐性）
if (!resource) {
  return res.status(404).json(createErrorResponse('NOT_FOUND', 'リソースが見つかりません'))
}

if (resource.tenantId !== authUser.tenantId) {
  return res.status(404).json(createErrorResponse('NOT_FOUND', 'リソースが見つかりません'))
}

// ❌ 禁止（列挙耐性なし）
if (!authUser) {
  return res.status(401).json(...)  // ← これはOK
}

if (resource.tenantId !== authUser.tenantId) {
  return res.status(403).json(...)  // ← NG: 404にすべき
}
```

**404ポリシーまとめ**:
- **401**: 未認証（セッションなし、トークン無効等）
- **404**: リソース不在、他テナント所有、権限なし（列挙耐性）
- **403**: システム管理者権限不足（列挙OK）

#### Step 6: switch-tenant配置確認（特定API）

**SSOT定義**（★太字再掲）:
- **エンドポイント**: `POST /api/v1/admin/switch-tenant`
- **実装場所**: `src/routes/switch-tenant.routes.ts`（**独立ファイル**）
- **登録方法**: `app.use('/api/v1/admin/switch-tenant', switchTenantRouter)`

**❌ 禁止**:
- `tenants.routes.ts` に配置（→ `/api/v1/admin/tenants/switch-tenant` になる）
- `auth.routes.ts` に配置（→ `/api/v1/admin/auth/switch-tenant` になる）

### 🔍 API実装時の自己診断チェックリスト

実装開始前に**必ず**自問：

- [ ] **SSOT定義を確認したか？**
  - ✅ grep -nE で HTTPメソッド + パスを検索済み
  - ❌ 機能名だけで曖昧検索
  
- [ ] **エンドポイントパスがSSO**T**定義と一致しているか？**
  - ✅ 完全一致（1文字も違わない）
  - ❌ 「だいたい合ってる」
  
- [ ] **ルーター登録がSSO**T**定義と一致しているか？**
  - ✅ B方式（router相対、app.use絶対）を使用
  - ❌ A/B方式混在（二重付与の原因）
  
- [ ] **深いネスト禁止ルールを確認したか？**
  - ✅ `/api/v1/admin/[resource]` のみ
  - ❌ `/api/v1/admin/[親]/[id]/[子]/[id]`
  
- [ ] **認証allowlistを確認したか？**
  - ✅ /health, /auth/* はミドルウェア外
  - ❌ 全てのルートに認証適用
  
- [ ] **404ポリシーを理解したか？**
  - ✅ 未認証=401、不在/他テナント=404
  - ❌ 他テナント=403（列挙耐性なし）

### 🚨 自動チェックスキャン（実装後）

**実装完了後に必ず実行**:

```bash
# hotel-saas（Nitro）: 禁止パターン検出
cd /Users/kaneko/hotel-saas-rebuild

echo "=== index.*ファイル検出 ==="
find server/api/v1/admin -name "index.*" 2>/dev/null && echo "❌ 検出" || echo "✅ なし"

echo ""
echo "=== 深いネスト検出 ==="
find server/api/v1/admin -path "*/\[*\]/*/\[*\]/*" 2>/dev/null && echo "❌ 検出" || echo "✅ なし"

# 共通: 二重付与検出
echo ""
echo "=== 二重付与検出（/api/api/） ==="
grep -R '/api/api/' src/server src/routes 2>/dev/null && echo "❌ 検出" || echo "✅ なし"

# hotel-common: ルート実在確認
echo ""
echo "=== ルート実在確認 ==="
ls -la src/routes/switch-tenant.routes.ts 2>/dev/null && echo "✅ 存在" || echo "❌ 不在"
```

### 🔒 CORS/Cookie設定確認（必須）

**開発環境設定**:
```typescript
// hotel-common（Express）
app.use(cors({
  origin: 'http://localhost:3101',  // hotel-saas限定
  credentials: true                  // Cookie転送必須
}))

res.cookie('hotel_session', sessionId, {
  httpOnly: true,
  secure: false,      // 開発環境
  sameSite: 'lax',
  path: '/',
  maxAge: 8 * 60 * 60 * 1000
})
```

**curl検証（必須）**:
```bash
# Cookie保存
curl -s -c /tmp/cookies.txt -X POST http://localhost:3401/api/v1/admin/auth/login \
  -H 'Content-Type: application/json' \
  -d '{"email":"owner@test.omotenasuai.com","password":"owner123"}' | jq .

# Cookie使用
curl -s -b /tmp/cookies.txt http://localhost:3401/api/v1/admin/tenants | jq .
```

---

## 🌐 API実装ルール（Nuxt 3 / Nitro制約）

```typescript
// ❌ 禁止パターン：深いネスト
// /server/api/v1/admin/orders/[id]/items/[itemId].get.ts

// ❌ 禁止パターン：index.*ファイル
// /server/api/v1/admin/rooms/index.get.ts

// ✅ 推奨パターン：フラット構造
// /server/api/v1/admin/order-items/[itemId].get.ts

// ✅ 推奨パターン：クエリパラメータ活用
// /server/api/v1/admin/order-items.get.ts?orderId=123
```

**理由**: Nuxt 3のVue Routerが干渉し、404エラーの原因となる

**参照**:
- 📖 `/Users/kaneko/hotel-kanri/docs/01_systems/saas/API_ROUTING_GUIDELINES.md`
- 📖 `/Users/kaneko/hotel-kanri/.cursor/prompts/api_routing_standard_reference.md`

---

## 🔐 認証・セキュリティルール（CRITICAL）

### Session認証（Redis + HttpOnly Cookie）

```typescript
// ✅ 正しいセッション取得
const sessionId = getCookie(event, 'hotel_session');
const session = await getSession(sessionId);

if (!session || !session.user) {
  throw createError({
    statusCode: 401,
    message: '認証が必要です'
  });
}

// セッションから情報取得
const tenantId = session.tenantId;
const userId = session.user.id;
```

**絶対ルール**:
- ✅ 全ての保護されたAPIで認証チェック必須
- ✅ セッション情報の検証
- ✅ テナントID・ユーザーIDの取得
- ❌ 認証回避は絶対禁止

**参照**:
- 📖 `/Users/kaneko/hotel-kanri/docs/03_ssot/00_foundation/SSOT_SAAS_ADMIN_AUTHENTICATION.md`

---

### 🧪 テスト用アカウント情報

**絶対ルール**: テストやデバッグ時は必ず以下のアカウントを使用する

#### 認証情報

| 項目 | 値 |
|------|-----|
| **Email** | `owner@test.omotenasuai.com` |
| **Password** | `owner123` |
| **Tenant ID** | `tenant-003bc06e-4ea0-4f93-9ce2-bf56dfe237b7` |

#### ログインコマンド（curl）

```bash
# hotel-saas-rebuild経由
curl -s -c /tmp/cookies.txt -X POST http://localhost:3101/api/v1/admin/auth/login \
  -H 'Content-Type: application/json' \
  -d '{"email":"owner@test.omotenasuai.com","password":"owner123"}' | jq .

# hotel-common-rebuild直接
curl -s -c /tmp/cookies.txt -X POST http://localhost:3401/api/v1/admin/auth/login \
  -H 'Content-Type: application/json' \
  -d '{"email":"owner@test.omotenasuai.com","password":"owner123"}' | jq .
```

#### ヘルスチェックURL

- **hotel-common-rebuild**: `http://localhost:3401/health` （認証不要）
- **hotel-saas-rebuild**: `http://localhost:3101/api/v1/health` （認証不要）

**詳細**: `/Users/kaneko/hotel-kanri/docs/setup/TEST_ACCOUNTS.md`

---

### ★★★ hotel-saas → hotel-common API呼び出しの必須パターン（CRITICAL）

**絶対ルール**: hotel-saasから hotel-common を呼び出す場合、**必ず `callHotelCommonAPI` を使用**

#### ✅ 正しい実装（Cookie自動転送）

```typescript
import { callHotelCommonAPI } from '~/server/utils/api-client'

export default defineEventHandler(async (event) => {
  // 認証チェック（ミドルウェアで認証済み）
  const user = event.context.user
  if (!user) {
    throw createError({ statusCode: 401, statusMessage: 'ログインが必要です' })
  }

  // 🔑 SSOT準拠: callHotelCommonAPIを使用（Cookie自動転送）
  const response = await callHotelCommonAPI(event, '/api/v1/your-endpoint', {
    method: 'POST',
    body: payload
  })

  return { success: true, data: response.data }
})
```

#### ❌ 絶対禁止（Cookie転送なし → 401エラー）

```typescript
// ❌ 禁止パターン1: $fetch直接使用
const hotelCommonApiUrl = process.env.HOTEL_COMMON_API_URL || 'http://localhost:3400'
const response = await $fetch(`${hotelCommonApiUrl}/api/v1/your-endpoint`, {
  method: 'POST',
  body: payload
})

// ❌ 禁止パターン2: credentials: 'include' でもサーバー間通信では不十分
const response = await $fetch(url, {
  credentials: 'include', // ← サーバー間では効かない
  body: payload
})
```

#### 🚨 なぜこのルールが重要か

- **hotel-saasはプロキシ専用システム**
- **認証はSession（Redis + HttpOnly Cookie）方式**
- **サーバー間通信でCookieを転送するには明示的な`Cookie`ヘッダー設定が必要**
- **`callHotelCommonAPI`はこれを自動で行う**
- **このパターンを守らないと全ての管理画面APIで401エラーが発生**

#### 📋 実装前チェックリスト

SSOT実装時、hotel-saas API実装では以下を**必ず**確認：

- [ ] `callHotelCommonAPI`をインポートしたか？
- [ ] 第1引数に`event`を渡したか？
- [ ] 第2引数にAPIパス（相対パス）を渡したか？
- [ ] 第3引数に`method`と`body`を渡したか？
- [ ] `$fetch`や`fetch`を直接使用していないか？
- [ ] `HOTEL_COMMON_API_URL`を直接使用していないか？

**詳細**: `/Users/kaneko/hotel-kanri/.cursor/prompts/implement_from_ssot.md` Phase 5-5

---

## 📚 必須参照ドキュメント

### SSOT作成時（必読）

**★★★最優先必読ドキュメント**: `/Users/kaneko/hotel-kanri/.cursor/prompts/ssot_creation_complete_flow.md`

このドキュメントは以下の3つを統合した完全版です：
- Phase 1: 作成前チェック（write_new_ssot.md）
- Phase 2: 作成中の品質基準（SSOT_QUALITY_CHECKLIST.md）
- Phase 3: 作成後の品質検証（retest_new_ssot.md）

**補足ドキュメント**:
1. `/Users/kaneko/hotel-kanri/docs/03_ssot/00_foundation/SSOT_QUALITY_CHECKLIST.md` - 詳細な品質基準
2. `/Users/kaneko/hotel-kanri/docs/03_ssot/00_foundation/SSOT_REQUIREMENT_ID_SYSTEM.md` - 要件ID体系
3. `/Users/kaneko/hotel-kanri/docs/03_ssot/SSOT_CREATION_RULES.md` - 作成ルール詳細

### SSOT実装時（必読）
1. **`/Users/kaneko/hotel-kanri/.cursor/prompts/implement_from_ssot.md`** - ★★★最優先
   - 実装前の必須チェックリスト（Phase 1-6）
   - 依存関係トレース（必須）← ★NEW
   - 実装プラン・テストプラン作成

2. **`/Users/kaneko/hotel-kanri/.cursor/prompts/ssot_dependency_trace.md`** - ★★★必須（NEW）
   - データフロー逆トレース手順
   - 実装必須箇所の完全抽出
   - 実装漏れ防止チェックリスト

3. **`/Users/kaneko/hotel-kanri/docs/03_ssot/00_foundation/SSOT_IMPLEMENTATION_CHECKLIST.md`** - ★★★最優先
   - 実装前の既存コード調査（15分）
   - 実装後の単体テスト（10分）
   - よくあるエラーパターンと対処法

4. `/Users/kaneko/hotel-kanri/.cursor/prompts/ssot_implementation_guard.md` - 実装ガードレール

### データベース関連
1. `/Users/kaneko/hotel-kanri/docs/standards/DATABASE_NAMING_STANDARD.md` - 命名規則
2. `/Users/kaneko/hotel-kanri/.cursor/prompts/database_naming_standard_reference.md` - クイックリファレンス

### API関連
1. `/Users/kaneko/hotel-kanri/docs/standards/API_ENDPOINT_NAMING_STANDARD.md` - ★★★エンドポイント命名標準（最優先）
2. `/Users/kaneko/hotel-kanri/docs/01_systems/saas/API_ROUTING_GUIDELINES.md` - ルーティングガイドライン
3. `/Users/kaneko/hotel-kanri/.cursor/prompts/api_routing_standard_reference.md` - クイックリファレンス

---

## ⚡ クイックリファレンス

### 「慌てて修正」ではなく「SSOTを確認」

```
エラー発生
  ↓
❌ すぐに修正（間違い）
✅ SSOT確認（正しい）
  ↓
記載あり → SSOT準拠実装
記載なし → ユーザーに質問
```

### システム境界の確認

```
hotel-saas → hotel-common → PostgreSQL
            → Redis（認証用）

❌ hotel-saas → PostgreSQL（禁止）
❌ hotel-saas → Prisma（禁止）
```

---

## 🛠️ 技術スタック（統一）

### フロントエンド
- **Framework**: Vue 3 + Nuxt 3
- **言語**: TypeScript（strictモード）
- **UIライブラリ**: Vuetify 3（Material Design 3公式実装）
- **カスタムテーマ**: 日本の伝統色パレット（Sass変数）
- **アイコン**: Heroicons優先（Iconify経由）、mdi補完
- **状態管理**: Composables（Pinia不使用）

### バックエンド
- **hotel-saas**: Nuxt 3 Server（プロキシ専用）
- **hotel-common**: Express + TypeScript（API基盤）
- **hotel-member**: FastAPI + Python
- **hotel-pms**: Express + TypeScript

### データベース・キャッシュ
- **DB**: PostgreSQL（統一DB）
- **ORM**: Prisma
- **Cache/Session**: Redis
- **Cookie**: HttpOnly Cookie

### 認証
- **方式**: Session認証（Redis + HttpOnly Cookie）
- **Cookie名**: `hotel_session`
- ❌ JWT認証は非推奨（過去の仕様）

---

## 🤖 AI役割定義（日本神話ベース）

### ☀️ Sun（天照大神） - hotel-saas担当
- **特性**: 明るく温かい、希望を与える、親しみやすい
- **重点**: 顧客体験向上、UI/UX、アクセシビリティ
- **絶対禁止**: 
  - 顧客・予約情報の更新
  - Prisma直接使用
  - hotel-commonのDBに直接アクセス

### 🌙 Luna（月読） - hotel-pms担当
- **特性**: 冷静沈着、確実遂行、24時間対応
- **重点**: フロント業務効率化、予約管理、オペレーション
- **絶対禁止**:
  - 他システムDB操作
  - イベント無し予約操作
  - ダブルブッキング

### ⚡ Suno（須佐之男） - hotel-member担当
- **特性**: 力強い、顧客守護、正義感、信頼性
- **重点**: 顧客管理、プライバシー保護、セキュリティ
- **絶対禁止**:
  - tenant_id無しクエリ
  - イベント無し更新
  - 直接SQL

### 🌊 Iza（伊邪那岐） - hotel-common担当
- **特性**: 創造神、基盤構築、調和秩序
- **重点**: システム統合、アーキテクチャ設計、基盤創造
- **絶対禁止**:
  - システム固有ロジック実装
  - 非互換変更
  - 認証回避

---

## ✅ 実装開始前のチェックリスト

### 必ず確認すること

```markdown
実装開始前に以下を**必ず**確認：

[ ] 1. 該当SSOTを読んだか？
[ ] 2. システムの役割を理解したか？
    - hotel-saas: プロキシ専用
    - hotel-common: API基盤・DB層
[ ] 3. 実装方針をユーザーに提案したか？
[ ] 4. ユーザーの承認を得たか？
[ ] 5. データベース命名規則を確認したか？
[ ] 6. API routing制約を確認したか？
[ ] 7. 認証方式を理解したか？
[ ] 8. マルチテナント要件を理解したか？
```

### エラー発生時の対応

```markdown
エラーが出たら:

❌ やってはいけないこと:
- すぐに修正しようとする
- 推測で実装を続ける
- 「動けばいい」という発想

✅ 正しい対応:
1. 実装を停止
2. 該当SSOTを読み直す
3. ガードレール確認
4. ユーザーに質問（記載がない場合）
5. 承認後に実装再開
```

---

## 🎯 品質基準

### コード品質
- ✅ TypeScript strictモード必須
- ✅ `any`型禁止（`unknown`を使用）
- ✅ エラーハンドリング必須（try/catch）
- ✅ JSDocコメント（複雑なロジック）

### パフォーマンス
- ✅ API応答: 300ms以内
- ✅ UI描画: 2秒以内
- ✅ N+1クエリ回避（並列処理活用）
- ✅ 適切なキャッシュ戦略

### セキュリティ
- ✅ 入力検証（全てのユーザー入力）
- ✅ SQLインジェクション対策（Prisma使用）
- ✅ XSS対策（出力エスケープ）
- ✅ CSRF対策（トークン検証）

---

## 📊 段階的アプローチ（必須）

### 複雑な問題は4段階で解決

```markdown
Phase 1: 情報収集
- 関連ドキュメント読み込み
- 既存実装確認
- 制約条件の把握

Phase 2: 詳細分析
- 要件の分解
- 影響範囲の特定
- リスクの評価

Phase 3: 差分評価
- 「あるべき姿」と「現状」の比較
- 実装工数の見積もり
- 不確実性の明記

Phase 4: 結論導出
- 実装方針の提案
- ユーザーへの説明
- 承認待ち
```

**絶対禁止**:
- ❌ 「雰囲気で判断」
- ❌ Phase 1-3を飛ばす
- ❌ 「完全一致」「追加実装不要」等の断定的表現

---

## 🔄 このルールの更新

このルールは定期的に更新されます。
最新版は常に `/Users/kaneko/hotel-kanri/.cursorrules` を参照してください。

**最終更新**: 2025年10月5日  
**バージョン**: 2.0.0（包括的統合版）  
**管理者**: Luna (hotel-kanri統合管理)

---

## 📋 プロンプトテンプレート（`>> prmt`タグ）

**最終更新**: 2025年12月19日  
**バージョン**: 2.6.0  
**更新内容**: 
- 機能実装（Full Stack）テンプレート追加、Gatekeeper要件統合（v2.0.0）
- SSOT照合ゲートの>> prmt内蔵（v2.1.0）
- システム境界違反の自動検査追加（v2.1.0）
- ルーティングA/B方式の固定宣言（B方式）（v2.1.0）
- allowlist強制チェック追加（v2.1.0）
- 404ポリシー・Set-Cookie透過・登録順サンプルの自動挿入（v2.1.0）
- Evidence強化（SSOT引用・ルーティング配置必須化）（v2.1.0）
- State自動更新（Backlog → In Progress）（v2.2.0）
- **Phase 0: 実装状況完全スキャン追加**（v2.3.0）:
  - 関連キーワード網羅抽出
  - Git管理下・履歴・PRマージ済み確認（必須コマンド4種）
  - 実装状況サマリー作成
  - スコープ不明時の対話質問
- **標準テストプロトコルの導入**（v2.4.0）
  - commit/PR前に標準テストスクリプトを必須実行
  - 失敗時はcommit/PR禁止（ローカルで修正→再実行）
  - PR本文に実行ログのEvidence貼付を必須化
- **標準テスト分離対応**（v2.5.0）
  - 管理画面用: `test-standard-admin.sh`（Session認証）
  - ゲスト画面用: `test-standard-guest.sh`（デバイス認証）
  - 実装タイプに応じたスクリプト選択を明記
- **★NEW APIレジストリ必須参照**（v2.6.0）
  - API実装タスクではSSOT_API_REGISTRY.mdを必須参照
  - エンドポイント存在確認・ルーター登録確認を自動挿入
  - hotel-common/hotel-saas両方の整合性チェック

### 目的

実装AIが100%意図通りに実装できるプロンプトを標準化し、品質を担保する。

### 使い方

```
>> prmt [タスクID]
```

**例**:
```
>> prmt COM-81
```

### 動作フロー（v2.6.0）

1. **Planeタスク取得**
   ```bash
   cd /Users/kaneko/hotel-kanri/scripts/plane
   node get-issue-detail.cjs [タスクID]
   ```

2. **★NEW APIレジストリ参照（API実装タスクの場合・必須）**
   
   **必読SSOT**: `/Users/kaneko/hotel-kanri/docs/03_ssot/00_foundation/SSOT_API_REGISTRY.md`
   
   **確認事項**:
   ```markdown
   ✅ API実装前の必須チェック:
   1. [ ] SSOT_API_REGISTRY.md にエンドポイントが定義されているか？
   2. [ ] hotel-common-rebuild のルートファイルが存在するか？
   3. [ ] hotel-common-rebuild/src/server/index.ts にルーター登録されているか？
   4. [ ] hotel-saas-rebuild にプロキシファイルが存在するか？
   
   ❌ レジストリ未定義のAPIは実装禁止
   ❌ ルーター登録なしのルートファイルは無効
   ```
   
   **判定**:
   - **未定義**: プロンプト生成中断 → ユーザーに「レジストリに追加が必要」を報告
   - **定義済み**: ルーター登録状況を確認 → プロンプトに整合性チェックを挿入

3. **State自動更新（Backlog → In Progress）**
   
   **条件**: `issue.state.name === "Backlog"`
   
   **処理**:
   ```bash
   # State ID定義（プロジェクト固有）
   BACKLOG_STATE_ID="2564ad4a-abd6-4b05-9af0-2c3dcd28e2be"
   IN_PROGRESS_STATE_ID="c576eed5-315c-44b9-a3cb-db67d73423b7"
   DONE_STATE_ID="86937979-4727-4ec9-81be-585f7aae981d"
   
   # State確認
   if [ "$STATE_NAME" = "Backlog" ]; then
     # In Progress に変更
     cd /Users/kaneko/hotel-kanri/scripts/plane
     node update-issue-state.cjs [タスクID] $IN_PROGRESS_STATE_ID
     echo "✅ ${タスクID}: Backlog → In Progress"
   fi
   ```
   
   **スキップ条件**:
   - State = "In Progress" → 既に作業中なので更新不要
   - State = "In Audit" → 監査中なので更新不要
   - State = "Done" → 完了済みタスクは再開しない（エラー報告）
   
   **依存関係チェック**:
   ```javascript
   if (issue.blocked_by && issue.blocked_by.length > 0) {
     console.error(`⚠️  ${taskId}: 依存タスクが未完了です`)
     console.error(`  Blocked by: ${issue.blocked_by.map(b => b.name).join(', ')}`)
     console.error(`  先に依存タスクを完了させてください。`)
     process.exit(1)
   }
   ```

3. **★NEW Phase 0: 実装状況完全スキャン（必須・5分）**
   
   **目的**: タスク関連の全実装状況を確認（Untracked filesだけでは不十分）
   
   **Step 1: 関連キーワード抽出**
   ```bash
   # タスクタイトルからキーワード抽出
   # 例: "[Phase 2] テナント管理実装" → tenant, room, grade等
   
   # SSOTから関連キーワード抽出（タスクDescriptionにSSOT参照がある場合）
   
   # 既存実装から推測されるキーワード抽出
   ```
   
   **Step 2: 実装状況の完全スキャン（必須コマンド4種）**
   ```bash
   # 1. Untracked files確認
   cd /Users/kaneko/hotel-common-rebuild
   git status
   cd /Users/kaneko/hotel-saas-rebuild
   git status
   
   # 2. Git管理下の全ファイル確認
   cd /Users/kaneko/hotel-common-rebuild
   git ls-files src/routes/ src/utils/ | grep -i '<keyword>'
   cd /Users/kaneko/hotel-saas-rebuild
   git ls-files server/api/v1/admin/ server/utils/ | grep -i '<keyword>'
   
   # 3. コミット履歴確認
   cd /Users/kaneko/hotel-common-rebuild
   git log --all --oneline --name-only -- src/routes/ src/utils/ | grep -i '<keyword>'
   cd /Users/kaneko/hotel-saas-rebuild
   git log --all --oneline --name-only -- server/api/v1/admin/ server/utils/ | grep -i '<keyword>'
   
   # 4. 直近PRマージ済み確認
   cd /Users/kaneko/hotel-common-rebuild
   gh pr list --state merged --search '<keyword>' | head -10
   cd /Users/kaneko/hotel-saas-rebuild
   gh pr list --state merged --search '<keyword>' | head -10
   ```
   
   **Step 3: 実装状況サマリー作成**
   ```markdown
   ## 📊 実装状況サマリー
   
   ### hotel-common側
   - ✅ `response-helpers.ts`: マージ済み（PR #XX）
   - ✅ `session-helpers.ts`: マージ済み（PR #XX）
   - ✅ `switch-tenant.routes.ts`: マージ済み（PR #XX）
   - ⚠️ `tenants.routes.ts`: Untracked（未コミット）
   - ❌ `xxx.routes.ts`: 未実装
   
   ### hotel-saas側
   - ✅ `switch-tenant.post.ts`: マージ済み（PR #XX）
   - ⚠️ `tenants/*.ts`: Untracked（未コミット）
   - ❌ `xxx/*.ts`: 未実装
   ```
   
   **Step 4: ユーザーにスコープ確認**
   
   **スコープが明確な場合**: プロンプト生成継続
   
   **スコープが不明確な場合**: プロンプト生成中断 → ユーザーに確認
   ```markdown
   🚨 実装スコープが不明確です。ユーザーに確認してください。
   
   【確認事項】
   - hotel-common側の実装対象は？
     - [ ] response-helpers.ts
     - [ ] session-helpers.ts
     - [ ] switch-tenant.routes.ts
     - [ ] tenants.routes.ts
     - [ ] その他: _______
   
   - hotel-saas側の実装対象は？
     - [ ] switch-tenant.post.ts
     - [ ] tenants/*.ts
     - [ ] その他: _______
   
   - Untracked filesは本タスクに含める？
     - [ ] はい（コミット→マージまで実施）
     - [ ] いいえ（別タスクとして扱う）
   ```
   
   **禁止パターン**:
   - ❌ Untracked filesのみで判断（Git管理下を見落とす）
   - ❌ コミット履歴・PR履歴を確認しない
   - ❌ スコープを推測で決め打ち（ユーザー確認なし）
   - ❌ 関連キーワードの網羅スキャン未実施

4. **タスクタイプ判定**（優先順位順）
   - **"[Phase N]"** → `FEATURE_IMPLEMENTATION.md`（★最優先）
   - "[11] UI" → `UI_IMPLEMENTATION.md`
   - "[12] API" → `API_IMPLEMENTATION.md`（未実装）
   - "[13] DB" → `DB_MIGRATION.md`（未実装）
   - **その他** → ユーザーに確認

5. **SSOT照合ゲート（★NEW・必須）**
   ```bash
   # SSOTでエンドポイント定義を検索（API実装タスクの場合）
   grep -nE '^(GET|POST|PUT|PATCH|DELETE)\s+/api/v1/admin/' \
     /Users/kaneko/hotel-kanri/docs/01_systems/saas/API_ROUTING_GUIDELINES.md | grep -i [機能名]
   ```
   
   **判定**:
   - **0件**: プロンプト生成中断 → ユーザーに「SSOT未定義」を報告
   - **2件以上**: プロンプト生成中断 → ユーザーに「複数一致・選択依頼」を報告
   - **1件**: プロンプト生成継続

6. **テンプレート読み込み**
   ```bash
   cat /Users/kaneko/hotel-kanri/docs/standards/prompt-templates/[テンプレート名].md
   ```

7. **タスク情報を反映**
   - タイトル: [タスクID]
   - SSOT参照: [Descriptionから抽出]
   - 依存関係: [Blocked by等]
   - SSOT引用: [Step 5で取得したエンドポイント定義]

8. **自動挿入（API実装タスクのみ・★NEW）**
   
   **判定**: タスクがAPI実装を含む場合、以下を自動挿入
   
   **挿入A: ルーティングポリシー（Item 1と Item 2/3の間）**:
   ```markdown
   ## 🚨 API実装前の必須確認（★★★CRITICAL）
   
   **絶対ルール**: API実装を開始する前に、必ず以下を確認する
   
   ### Step 0-1: SSOT定義のエンドポイントパス確認
   
   \`\`\`bash
   # SSOTでエンドポイントパスを検索（HTTPメソッドと正規表現で厳密に）
   grep -nE '^(GET|POST|PUT|PATCH|DELETE)\\s+/api/v1/admin/' \\
     /Users/kaneko/hotel-kanri/docs/01_systems/saas/API_ROUTING_GUIDELINES.md | grep -i [機能名]
   \`\`\`
   
   ### Step 0-2: 自己診断チェックリスト
   
   - [ ] SSOT定義を確認したか？
   - [ ] エンドポイントパスがSSO**T**定義と完全一致しているか？
   - [ ] ベースパスが `/api/v1/admin/[resource]` 形式か？
   - [ ] 深いネスト禁止ルールを確認したか？
   - [ ] B方式（router相対 + app.use絶対）を採用しているか？
   - [ ] 認証allowlist確認したか？
   - [ ] 404ポリシー（未認証=401、不在/他テナント=404）を理解したか？
   
   ### Step 0-3: Evidence - Routing（実装前スキャン）
   
   \`\`\`bash
   # 二重付与検出
   grep -R '/api/api/' src/server src/routes 2>/dev/null && echo "❌ 検出" || echo "✅ なし"
   
   # ルート実在確認
   ls -la src/routes/[ルートファイル名].routes.ts 2>/dev/null && echo "✅ 存在" || echo "❌ 不在"
   \`\`\`
   ```
   
   **挿入B: 実装中断ポリシー（冒頭・全タスク共通）**:
   ```markdown
   ## 🚨 重要：実装中断の基準（必読）
   
   **絶対ルール**: 以下の場合、実装を即座に停止してユーザーに報告する
   
   ### 必須停止トリガー（Layer 1）
   1. SSOT照合失敗（0件）or SSOT複数一致
   2. ルーティング不一致（深いネスト/二重付与/A/B混在/B方式違反/index.*ファイル/allowlist違反）
   3. システム境界違反（common にNitro構成/saasでPrisma直/saasで$fetch直）
   4. 依存ファイル非実在
   5. 型エラー連鎖（>5件）
   6. Prismaスキーマ変更
   7. tenant_idフォールバック/環境分岐
   8. 矛盾の発見
   9. エラー原因不明（15分以上・試したコマンド/結果/仮説を報告）
   
   詳細: implementation_halt_protocol.md v1.2.0
   ```

9. **プロンプト出力（チャット内）**
   - ✅ チャット内で全文を出力
   - ✅ **全タスク共通**: 実装中断ポリシー（挿入B）を冒頭に自動挿入
   - ✅ **API実装タスクの場合**: ルーティングポリシー（挿入A）を追加挿入
   - ✅ **API実装タスクの場合**: 404ポリシー・Set-Cookie透過・登録順サンプルを追加挿入
   - ✅ システム別分岐（hotel-common=Express / hotel-saas=Nitro）
   - ✅ SSOT引用を必須化（該当行を明示）
   - ✅ Evidence - Routing（実装前スキャン）を常設
   - ❌ ファイル化しない（`.cursorrules`の原則に従う）

### >> prmt 自動挿入まとめ

| 挿入内容 | 対象タスク | 挿入位置 | 目的 |
|---------|----------|---------|------|
| **挿入B: 実装中断ポリシー** | **全タスク** | **冒頭** | 停止トリガーの周知 |
| **挿入A: ルーティングポリシー** | **API実装タスク** | **Item 1と Item 2/3の間** | ルーティング違反防止 |

### 生成後の確認事項

次回 `>> prmt [タスクID]` 実行時、以下を確認：
- [ ] 冒頭に「🚨 重要：実装中断の基準」が含まれているか？
- [ ] API実装タスクの場合、「🚨 API実装前の必須確認」が含まれているか？
- [ ] 自己診断チェックリスト、Evidence - Routingが含まれているか？
- [ ] システム別分岐（hotel-common/hotel-saas）が正しいか？

### 親タスク完了ルール（★NEW・必須）

**サブタスクが全て完了したら、親タスクもDoneにする**

```markdown
親タスク命名規則:
- 親: DEV-0160（末尾が0）
- 子: DEV-0161〜0169（末尾が1-9）

子タスク全Done → 親タスクもDone
```

**自動チェックスクリプト**:
```bash
cd /Users/kaneko/hotel-kanri/scripts/plane
node check-parent-completion.cjs --dry-run  # 確認
node check-parent-completion.cjs            # 実行
```

**タスク完了時の必須フロー**:
1. サブタスクをDoneに更新
2. `check-parent-completion.cjs` を実行
3. 親タスクが自動でDoneに更新される

### テンプレート一覧

| テンプレート | 用途 | 適用条件 | 場所 |
|-------------|------|----------|------|
| `FEATURE_IMPLEMENTATION.md`★NEW | 機能実装（Full Stack） | タイトルに"[Phase N]"を含む | `/Users/kaneko/hotel-kanri/docs/standards/prompt-templates/` |
| `UI_IMPLEMENTATION.md` | UI実装のみ | タスクに"[11] UI"を含む | `/Users/kaneko/hotel-kanri/docs/standards/prompt-templates/` |
| `API_IMPLEMENTATION.md` | API実装のみ | タスクに"[12] API"を含む | （未実装） |
| `DB_MIGRATION.md` | DB Migrationのみ | タスクに"[13] DB"を含む | （未実装） |
| `COMMON_SECTIONS.md`★更新 | 共通セクション | 全テンプレートで使用 | `/Users/kaneko/hotel-kanri/docs/standards/prompt-templates/` |

### プロンプトの必須要素（10項目）★Gatekeeper要件統合

1. **段階的な指示（Item/Step構造）**
   - Item 1: 事前調査（SSOT確認・スコープ判定）（必須・20分）
   - Item 2-7: 実装ステップ（Item別、各ItemにStep 1-N）

2. **具体的なツール使用指示**
   - `find`, `ls`, `cat`, `grep`, `search_replace`, `write`, `read_file`
   - コマンド例を明記（`bash`ブロック）

3. **検証可能な成果物の指定**
   - ファイル一覧（`ls -la`, `sha256sum`）
   - チェックリスト（`[ ]` 形式）

4. **エラー時の対処フロー明記**
   - 401/403/500/404エラー
   - 診断コマンド + 対処法

5. **各Item完了時の報告フォーマット**
   - Markdown形式のテンプレート
   - ユーザー承認待ち指示

6. **実行するコマンドの明示**
   - `bash`ブロックで全コマンドを明示
   - 終了コード記録（`echo "終了コード: $?"`）

7. **確認すべき項目のチェックリスト**
   - `[ ]` 形式、各Item毎に定義

8. **Evidence取得手順（Gatekeeper必須）**★NEW
   - Evidence 1: Commands & Logs（実行コマンド+終了コード）
   - Evidence 2: Files（git status, ls -la, sha256sum）
   - Evidence 3: Git（branch, HEAD）
   - Evidence 4: CI（PR作成後に追記）
   - Evidence 5: CRUD Verify（CI完了後に追記）

9. **PR本文テンプレート（Gatekeeper必須）**★NEW
   - 必須見出し4件（参照SSOT / Plane / テスト・証跡 / CI）
   - Evidence 1-5の貼付箇所明示
   - 受入基準チェックリスト

10. **不可侵ルール（即否認対象）**★NEW
    - hotel-saas からの Prisma/DB 直接使用
    - tenant_id フォールバック
    - $fetch 直接使用（Cookie未転送）
    - API Routingガイドライン違反
    - 環境分岐ロジック

11. **標準テストスクリプト選択**★NEW（v2.5.0）
    - **管理画面実装**: `test-standard-admin.sh`
      - 対象: `/api/v1/admin/*`, `/admin/*`
      - 認証: Session認証（Redis + Cookie）
      - 検証: ログイン → テナント切替 → API → UI SSR
    - **ゲスト画面実装**: `test-standard-guest.sh`
      - 対象: `/api/v1/guest/*`, `/menu`
      - 認証: デバイス認証（MAC/IP → device_rooms）
      - 検証: デバイス認証 → API → UI注意事項
    - **スクリプトパス**: `/Users/kaneko/hotel-kanri/scripts/`
    - **実行タイミング**: 実装完了後、commit/PR前に必須実行
    - **失敗時対応**: ローカル修正 → 再実行 → commit/PR

### 禁止事項

- ❌ 曖昧な表現（「適切に」「よしなに」等）
- ❌ プレースホルダー（「XXX」「...」等）
- ❌ ファイル一覧だけの指示
- ❌ ツール使用指示なし
- ❌ プロンプトのファイル化

### 詳細ガイド

**場所**: `/Users/kaneko/hotel-kanri/docs/standards/prompt-templates/README.md`

---

## 🎯 Marketing Injection Rules（マーケ視点の開発ルール）★NEW

**目的**: 高品質な機能開発と高速なマーケティングを両立させる

### Config First（ハードコード禁止）

**原則**: テキスト・文言・価格はハードコードしない

```typescript
// ❌ 禁止: ハードコード
const welcomeMessage = 'いらっしゃいませ！'
const price = 9800
const campaignText = '期間限定20%OFF'

// ✅ 推奨: Config/DB から取得
const welcomeMessage = await getConfig('ai.welcome_message', tenantId)
const price = await getTenantSetting('starter.price', tenantId)
const campaignText = await getI18n('campaign.limited_offer', tenantId)
```

**Config化すべき項目**:
- ✅ AIキャラクター名・口調・人格
- ✅ キャンペーン文言
- ✅ 価格・割引率
- ✅ 営業時間・表示設定

**ハードコードOKな項目**:
- ✅ システムエラーメッセージ（開発者向け）
- ✅ ログ出力メッセージ
- ✅ 技術的な定数（ポート番号、タイムアウト値等）

### Tracking by Default（計測必須）

**原則**: 全てのアクションに計測タグを入れる

```vue
<!-- ❌ 禁止: 計測タグなし -->
<button @click="sendMessage">送信</button>

<!-- ✅ 推奨: data-analytics-id 必須 -->
<button 
  data-analytics-id="ai-chat-send"
  @click="sendMessage"
>
  送信
</button>
```

```typescript
// APIログ必須
router.post('/', async (req, res) => {
  console.log('[POST /api/v1/xxx] tenantId:', tenantId)
  // 処理
})
```

**計測すべきイベント**:
| イベント | analytics-id | 記録先 |
|:---------|:-------------|:-------|
| AIチャット送信 | `ai-chat-send` | console + DB |
| AI推奨クリック | `ai-recommend-click` | DB必須 |
| カート追加 | `cart-add` | DB必須 |
| 注文確定 | `order-confirm` | DB必須 |

### Doc is Asset（ドキュメント = 資産）

**原則**: コードを書くのと同じくらい、ドキュメント維持は重要

- ✅ SSOT更新は機能変更とセットで実施
- ✅ トレーサビリティマトリクスを常に最新化
- ✅ 将来のバイアウト・DDに備えたドキュメント品質維持

**詳細SSOT**: `/Users/kaneko/hotel-kanri/docs/03_ssot/00_foundation/SSOT_MARKETING_INTEGRATION.md`（作成予定）

---

## 💡 重要な心構え

```
「慌てて修正」ではなく「SSOTを確認」
「想像で実装」ではなく「ドキュメント確認」
「いきなり実装」ではなく「まず相談」
「動けばいい」ではなく「正しく実装」
「プロンプトは命令のSSO」← NEW
```

**これらのルールは、AIの「判断基準」として常に参照されます。**

