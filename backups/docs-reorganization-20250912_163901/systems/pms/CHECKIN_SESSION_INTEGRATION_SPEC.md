# ğŸŒ™ hotel-pms ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³ã‚»ãƒƒã‚·ãƒ§ãƒ³çµ±åˆä»•æ§˜æ›¸

**å¯¾è±¡ã‚·ã‚¹ãƒ†ãƒ **: hotel-pms  
**æ‹…å½“AI**: Lunaï¼ˆæœˆèª­ - Tsukuyomiï¼‰  
**ä½œæˆæ—¥**: 2025å¹´1æœˆ19æ—¥  
**å„ªå…ˆåº¦**: ğŸ”´ **ç·Šæ€¥ãƒ»é«˜å„ªå…ˆåº¦**  
**å®Ÿè£…æœŸé™**: 2025å¹´2æœˆ1æ—¥

---

## ğŸ“‹ **çµ±åˆæ¦‚è¦**

hotel-pmsã‚·ã‚¹ãƒ†ãƒ ã«ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†æ©Ÿèƒ½ã‚’çµ±åˆã—ã€äºˆç´„ç®¡ç†ã‹ã‚‰ãƒ•ãƒ­ãƒ³ãƒˆæ¥­å‹™ã€è«‹æ±‚å‡¦ç†ã¾ã§ä¸€è²«ã—ãŸã‚»ãƒƒã‚·ãƒ§ãƒ³å˜ä½ã®ç®¡ç†ã‚’å®Ÿç¾ã—ã¾ã™ã€‚

### **Lunaï¼ˆæœˆèª­ï¼‰ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¨ã—ã¦ã®è²¬å‹™**
- **å†·é™æ²ˆç€**: 24æ™‚é–“ç„¡åœæ­¢é‹ç”¨ã‚’ç¶­æŒã—ãªãŒã‚‰ã®æ®µéšçš„çµ±åˆ
- **ç¢ºå®Ÿé‚è¡Œ**: ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ã‚’ä¿è¨¼ã—ãŸç¢ºå®Ÿãªå®Ÿè£…
- **åŠ¹ç‡é‡è¦–**: ãƒ•ãƒ­ãƒ³ãƒˆæ¥­å‹™ã®åŠ¹ç‡åŒ–ã‚’æœ€å„ªå…ˆ

---

## ğŸ¯ **çµ±åˆç›®æ¨™**

### **è§£æ±ºã™ã¹ãå•é¡Œ**
1. **äºˆç´„ã¨ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ä¹–é›¢**: äºˆç´„æƒ…å ±ã¨å®Ÿéš›ã®å®¿æ³Šã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ä¸ä¸€è‡´
2. **ãƒ•ãƒ­ãƒ³ãƒˆæ¥­å‹™ã®éåŠ¹ç‡**: éƒ¨å±‹ç•ªå·ãƒ™ãƒ¼ã‚¹ã®æ›–æ˜§ãªç®¡ç†
3. **è«‹æ±‚å‡¦ç†ã®è¤‡é›‘æ€§**: è¤‡æ•°ã®å®¿æ³ŠæœŸé–“ã«ã¾ãŸãŒã‚‹è«‹æ±‚ã®æ··åœ¨

### **é”æˆã™ã¹ãåŠ¹æœ**
1. **æ­£ç¢ºãªã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†**: ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³æ™‚ã®è‡ªå‹•ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆ
2. **åŠ¹ç‡çš„ãªãƒ•ãƒ­ãƒ³ãƒˆæ¥­å‹™**: ã‚»ãƒƒã‚·ãƒ§ãƒ³ç•ªå·ã«ã‚ˆã‚‹æ˜ç¢ºãªè­˜åˆ¥
3. **ç²¾å¯†ãªè«‹æ±‚å‡¦ç†**: ã‚»ãƒƒã‚·ãƒ§ãƒ³å˜ä½ã§ã®æ­£ç¢ºãªæ–™é‡‘è¨ˆç®—

---

## ğŸ”„ **ã‚·ã‚¹ãƒ†ãƒ çµ±åˆè¨­è¨ˆ**

### **1. ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³ãƒ•ãƒ­ãƒ¼æ”¹è‰¯**

#### **å¾“æ¥ã®ãƒ•ãƒ­ãƒ¼**
```
1. äºˆç´„æƒ…å ±ã®æ¤œç´¢ãƒ»ç¢ºèª
2. é¡§å®¢æƒ…å ±ã®ç¢ºèªãƒ»æ›´æ–°
3. éƒ¨å±‹å‰²ã‚Šå½“ã¦ãƒ»éµç™ºè¡Œ
4. ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³å‡¦ç†å®Ÿè¡Œ
5. checkin_checkout.checked_inã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ
```

#### **æ–°ã—ã„ãƒ•ãƒ­ãƒ¼**
```
1. äºˆç´„æƒ…å ±ã®æ¤œç´¢ãƒ»ç¢ºèª
2. é¡§å®¢æƒ…å ±ã®ç¢ºèªãƒ»æ›´æ–°
3. éƒ¨å±‹å‰²ã‚Šå½“ã¦ãƒ»éµç™ºè¡Œ
4. ğŸ†• ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆ
5. ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³å‡¦ç†å®Ÿè¡Œ
6. ğŸ†• session.createdã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ
7. checkin_checkout.checked_inã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œï¼ˆäº’æ›æ€§ç¶­æŒï¼‰
```

#### **ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆå‡¦ç†**
```typescript
interface CheckinProcessRequest {
  reservationId: string;
  roomId: string;
  customerId: string;
  guestInfo: GuestInfo;
  actualCheckInTime: Date;
  specialRequests?: string;
  frontDeskNotes?: string;
}

async function processCheckin(request: CheckinProcessRequest): Promise<{
  session: CheckinSession;
  billing: SessionBilling;
}> {
  // 1. ã‚»ãƒƒã‚·ãƒ§ãƒ³ç•ªå·ç”Ÿæˆ
  const sessionNumber = generateSessionNumber(
    request.roomId, 
    request.actualCheckInTime
  );
  
  // 2. ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆ
  const session = await sessionApi.createSession({
    reservationId: request.reservationId,
    roomId: request.roomId,
    customerId: request.customerId,
    guestInfo: request.guestInfo,
    checkInAt: request.actualCheckInTime,
    plannedCheckOut: reservation.checkOutDate,
    specialRequests: request.specialRequests,
    notes: request.frontDeskNotes
  });
  
  // 3. åˆæœŸè«‹æ±‚ä½œæˆ
  const billing = await createInitialBilling(session);
  
  // 4. éƒ¨å±‹çŠ¶æ…‹æ›´æ–°
  await updateRoomStatus(request.roomId, 'OCCUPIED');
  
  // 5. ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ
  await eventPublisher.publish('session.created', {
    sessionId: session.id,
    sessionNumber: session.sessionNumber,
    roomId: request.roomId,
    customerId: request.customerId,
    checkInAt: request.actualCheckInTime.toISOString(),
    guestInfo: request.guestInfo
  });
  
  return { session, billing };
}
```

### **2. ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆãƒ•ãƒ­ãƒ¼æ”¹è‰¯**

#### **å¾“æ¥ã®ãƒ•ãƒ­ãƒ¼**
```
1. å®¿æ³Šæ–™é‡‘ãƒ»è¿½åŠ æ–™é‡‘ã®è¨ˆç®—
2. è«‹æ±‚æ›¸ä½œæˆ
3. æ±ºæ¸ˆå‡¦ç†
4. ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆå‡¦ç†å®Ÿè¡Œ
5. checkin_checkout.checked_outã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ
6. billing.paidã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ
```

#### **æ–°ã—ã„ãƒ•ãƒ­ãƒ¼**
```
1. ğŸ†• ã‚»ãƒƒã‚·ãƒ§ãƒ³è«‹æ±‚ã®æœ€çµ‚è¨ˆç®—
2. ğŸ†• ã‚µãƒ¼ãƒ“ã‚¹æ³¨æ–‡ã®æœ€çµ‚ç¢ºèª
3. æ±ºæ¸ˆå‡¦ç†
4. ğŸ†• ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆå‡¦ç†
5. ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆå‡¦ç†å®Ÿè¡Œ
6. ğŸ†• session.checked_outã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ
7. checkin_checkout.checked_outã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œï¼ˆäº’æ›æ€§ç¶­æŒï¼‰
8. billing.paidã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ
```

#### **ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆå‡¦ç†**
```typescript
interface CheckoutProcessRequest {
  sessionId: string;
  actualCheckOutTime: Date;
  paymentMethod: PaymentMethod;
  paidAmount: number;
  frontDeskNotes?: string;
}

async function processCheckout(request: CheckoutProcessRequest): Promise<{
  session: CheckinSession;
  finalBilling: SessionBilling;
}> {
  // 1. ã‚»ãƒƒã‚·ãƒ§ãƒ³æƒ…å ±å–å¾—
  const session = await sessionApi.getSession(request.sessionId);
  
  // 2. æœ€çµ‚è«‹æ±‚è¨ˆç®—
  const finalBilling = await calculateFinalBilling(session.id);
  
  // 3. æ”¯æ‰•ã„å‡¦ç†
  await processFinalPayment(finalBilling.id, {
    paymentMethod: request.paymentMethod,
    paidAmount: request.paidAmount
  });
  
  // 4. ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
  const checkedOutSession = await sessionApi.checkoutSession(request.sessionId, {
    checkOutAt: request.actualCheckOutTime,
    finalBilling: {
      paymentMethod: request.paymentMethod,
      paidAmount: request.paidAmount,
      notes: request.frontDeskNotes
    }
  });
  
  // 5. éƒ¨å±‹çŠ¶æ…‹æ›´æ–°
  await updateRoomStatus(session.roomId, 'CLEANING');
  
  // 6. ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ
  await eventPublisher.publish('session.checked_out', {
    sessionId: session.id,
    sessionNumber: session.sessionNumber,
    checkOutAt: request.actualCheckOutTime.toISOString(),
    totalAmount: finalBilling.totalAmount,
    finalBilling
  });
  
  return { session: checkedOutSession, finalBilling };
}
```

### **3. ã‚µãƒ¼ãƒ“ã‚¹æ³¨æ–‡é€£æº**

#### **ã‚µãƒ¼ãƒ“ã‚¹æ³¨æ–‡ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†**
```typescript
// service.orderedã‚¤ãƒ™ãƒ³ãƒˆã®å‡¦ç†æ”¹è‰¯
async function handleServiceOrdered(event: ServiceOrderedEvent) {
  try {
    // 1. éƒ¨å±‹ç•ªå·ã‹ã‚‰ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚»ãƒƒã‚·ãƒ§ãƒ³å–å¾—
    const session = await sessionApi.getActiveSessionByRoom(event.data.roomId);
    
    if (!session) {
      throw new Error(`No active session found for room ${event.data.roomId}`);
    }
    
    // 2. ã‚»ãƒƒã‚·ãƒ§ãƒ³è«‹æ±‚ã«è¿½åŠ 
    await sessionBillingApi.addServiceCharge(session.id, {
      orderId: event.data.orderId,
      serviceId: event.data.serviceId,
      serviceName: event.data.serviceName,
      quantity: event.data.quantity,
      unitPrice: event.data.unitPrice,
      amount: event.data.amount,
      orderedAt: new Date(event.data.orderedAt)
    });
    
    // 3. ã‚»ãƒƒã‚·ãƒ§ãƒ³è«‹æ±‚æ›´æ–°ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ
    await eventPublisher.publish('session.billing_updated', {
      sessionId: session.id,
      billingId: session.billings[0].id,
      totalAmount: updatedBilling.totalAmount,
      paidAmount: updatedBilling.paidAmount,
      status: updatedBilling.status
    });
    
  } catch (error) {
    console.error('Failed to process service order:', error);
    // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ»ãƒªãƒˆãƒ©ã‚¤å‡¦ç†
  }
}
```

---

## ğŸ—„ï¸ **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆ**

### **1. æ—¢å­˜ãƒ†ãƒ¼ãƒ–ãƒ«ã®æ‹¡å¼µ**

#### **reservationsãƒ†ãƒ¼ãƒ–ãƒ«**
```sql
-- ã‚»ãƒƒã‚·ãƒ§ãƒ³é–¢é€£ã‚«ãƒ©ãƒ è¿½åŠ 
ALTER TABLE reservations 
ADD COLUMN active_session_id UUID REFERENCES checkin_sessions(id),
ADD COLUMN session_count INTEGER DEFAULT 0; -- åŒä¸€äºˆç´„ã§ã®è¤‡æ•°ã‚»ãƒƒã‚·ãƒ§ãƒ³å¯¾å¿œ

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¿½åŠ 
CREATE INDEX idx_reservations_active_session ON reservations(active_session_id);
```

#### **billingsãƒ†ãƒ¼ãƒ–ãƒ«**
```sql
-- ã‚»ãƒƒã‚·ãƒ§ãƒ³è«‹æ±‚ã¨ã®é–¢é€£ä»˜ã‘
ALTER TABLE billings 
ADD COLUMN session_billing_id UUID REFERENCES session_billings(id);

-- æ®µéšç§»è¡Œã®ãŸã‚ã€æ—¢å­˜ã®reservation_idã¯ä¿æŒ
CREATE INDEX idx_billings_session_billing ON billings(session_billing_id);
```

### **2. ãƒ“ãƒ¥ãƒ¼ä½œæˆ**

#### **ã‚»ãƒƒã‚·ãƒ§ãƒ³çµ±åˆãƒ“ãƒ¥ãƒ¼**
```sql
CREATE VIEW session_overview AS
SELECT 
  cs.id as session_id,
  cs.session_number,
  cs.status as session_status,
  cs.check_in_at,
  cs.check_out_at,
  cs.planned_check_out,
  
  -- äºˆç´„æƒ…å ±
  r.reservation_number,
  r.status as reservation_status,
  r.origin as reservation_origin,
  
  -- éƒ¨å±‹æƒ…å ±
  rm.room_number,
  rt.name as room_type,
  rg.name as room_grade,
  
  -- é¡§å®¢æƒ…å ±
  c.first_name,
  c.last_name,
  c.email,
  c.phone,
  c.member_id,
  
  -- è«‹æ±‚æƒ…å ±
  sb.billing_number as session_billing_number,
  sb.total_amount,
  sb.paid_amount,
  sb.status as billing_status,
  
  -- æ³¨æ–‡æƒ…å ±
  (SELECT COUNT(*) FROM service_orders so WHERE so.session_id = cs.id) as order_count,
  (SELECT SUM(so.amount) FROM service_orders so WHERE so.session_id = cs.id) as service_total

FROM checkin_sessions cs
LEFT JOIN reservations r ON cs.reservation_id = r.id
LEFT JOIN rooms rm ON cs.room_id = rm.id
LEFT JOIN room_types rt ON rm.room_type_id = rt.id
LEFT JOIN room_grades rg ON rm.room_grade_id = rg.id
LEFT JOIN customers c ON cs.customer_id = c.id
LEFT JOIN session_billings sb ON sb.session_id = cs.id;
```

---

## ğŸ–¥ï¸ **ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰çµ±åˆ**

### **1. ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³ç”»é¢ã®æ”¹è‰¯**

#### **ã‚»ãƒƒã‚·ãƒ§ãƒ³æƒ…å ±è¡¨ç¤ºã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ**
```vue
<template>
  <div class="session-info-card">
    <div class="session-header">
      <h3>ã‚»ãƒƒã‚·ãƒ§ãƒ³æƒ…å ±</h3>
      <span class="session-number">{{ sessionNumber }}</span>
    </div>
    
    <div class="session-details">
      <div class="detail-row">
        <label>éƒ¨å±‹ç•ªå·:</label>
        <span>{{ roomNumber }}</span>
      </div>
      <div class="detail-row">
        <label>ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³:</label>
        <span>{{ formatDateTime(checkInAt) }}</span>
      </div>
      <div class="detail-row">
        <label>äºˆå®šãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ:</label>
        <span>{{ formatDateTime(plannedCheckOut) }}</span>
      </div>
      <div class="detail-row">
        <label>å®¿æ³Šè€…:</label>
        <span>{{ guestInfo.primaryGuest.firstName }} {{ guestInfo.primaryGuest.lastName }}</span>
      </div>
      <div class="detail-row" v-if="guestInfo.additionalGuests.length > 0">
        <label>åŒä¼´è€…:</label>
        <span>{{ guestInfo.additionalGuests.length }}å</span>
      </div>
    </div>
    
    <div class="session-status">
      <span :class="['status-badge', statusClass]">
        {{ statusText }}
      </span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { CheckinSession } from '~/types/checkin-session'

interface Props {
  session: CheckinSession
}

const props = defineProps<Props>()

const sessionNumber = computed(() => props.session.sessionNumber)
const roomNumber = computed(() => props.session.room?.roomNumber || 'N/A')
const checkInAt = computed(() => props.session.checkInAt)
const plannedCheckOut = computed(() => props.session.plannedCheckOut)
const guestInfo = computed(() => props.session.guestInfo)

const statusClass = computed(() => {
  switch (props.session.status) {
    case 'ACTIVE': return 'status-active'
    case 'EXTENDED': return 'status-extended'
    case 'CHECKED_OUT': return 'status-checked-out'
    case 'CANCELED': return 'status-canceled'
    default: return 'status-unknown'
  }
})

const statusText = computed(() => {
  switch (props.session.status) {
    case 'ACTIVE': return 'æ»åœ¨ä¸­'
    case 'EXTENDED': return 'å»¶æ³Šä¸­'
    case 'CHECKED_OUT': return 'ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆæ¸ˆã¿'
    case 'CANCELED': return 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«'
    default: return 'ä¸æ˜'
  }
})

const formatDateTime = (date: Date) => {
  return new Intl.DateTimeFormat('ja-JP', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  }).format(new Date(date))
}
</script>
```

#### **ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³å‡¦ç†ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ**
```vue
<template>
  <div class="checkin-process">
    <form @submit.prevent="processCheckin">
      <div class="form-section">
        <h3>ã‚²ã‚¹ãƒˆæƒ…å ±ç¢ºèª</h3>
        <GuestInfoForm v-model="guestInfo" />
      </div>
      
      <div class="form-section">
        <h3>ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³è©³ç´°</h3>
        <div class="form-row">
          <label>å®Ÿéš›ã®ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³æ™‚åˆ»:</label>
          <input 
            type="datetime-local" 
            v-model="actualCheckInTime"
            required
          />
        </div>
        <div class="form-row">
          <label>ç‰¹åˆ¥ãƒªã‚¯ã‚¨ã‚¹ãƒˆ:</label>
          <textarea v-model="specialRequests" rows="3"></textarea>
        </div>
        <div class="form-row">
          <label>ãƒ•ãƒ­ãƒ³ãƒˆãƒ‡ã‚¹ã‚¯ãƒ¡ãƒ¢:</label>
          <textarea v-model="frontDeskNotes" rows="2"></textarea>
        </div>
      </div>
      
      <div class="form-actions">
        <button type="button" @click="cancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <button type="submit" :disabled="processing">
          {{ processing ? 'å‡¦ç†ä¸­...' : 'ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³å®Ÿè¡Œ' }}
        </button>
      </div>
    </form>
  </div>
</template>

<script setup lang="ts">
import type { Reservation, GuestInfo } from '~/types/checkin-session'

interface Props {
  reservation: Reservation
}

const props = defineProps<Props>()
const emit = defineEmits<{
  success: [session: CheckinSession]
  cancel: []
}>()

const { processCheckin: apiProcessCheckin } = usePmsApi()

const processing = ref(false)
const actualCheckInTime = ref(new Date().toISOString().slice(0, 16))
const specialRequests = ref(props.reservation.specialRequests || '')
const frontDeskNotes = ref('')

const guestInfo = ref<GuestInfo>({
  primaryGuest: {
    firstName: props.reservation.customer?.firstName || '',
    lastName: props.reservation.customer?.lastName || '',
    email: props.reservation.customer?.email || '',
    phone: props.reservation.customer?.phone || ''
  },
  additionalGuests: [],
  specialNeeds: [],
  preferences: {}
})

const processCheckin = async () => {
  processing.value = true
  
  try {
    const result = await apiProcessCheckin({
      reservationId: props.reservation.id,
      roomId: props.reservation.roomId,
      customerId: props.reservation.customerId,
      guestInfo: guestInfo.value,
      actualCheckInTime: new Date(actualCheckInTime.value),
      specialRequests: specialRequests.value,
      frontDeskNotes: frontDeskNotes.value
    })
    
    emit('success', result.session)
  } catch (error) {
    console.error('Checkin failed:', error)
    // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
  } finally {
    processing.value = false
  }
}

const cancel = () => {
  emit('cancel')
}
</script>
```

### **2. ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ç”»é¢**

#### **ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚»ãƒƒã‚·ãƒ§ãƒ³ä¸€è¦§**
```vue
<template>
  <div class="active-sessions">
    <div class="sessions-header">
      <h2>ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚»ãƒƒã‚·ãƒ§ãƒ³</h2>
      <div class="sessions-stats">
        <span>ç·ã‚»ãƒƒã‚·ãƒ§ãƒ³æ•°: {{ sessions.length }}</span>
        <span>ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆäºˆå®š: {{ todayCheckouts }}</span>
      </div>
    </div>
    
    <div class="sessions-grid">
      <div 
        v-for="session in sessions" 
        :key="session.id"
        class="session-card"
        @click="selectSession(session)"
      >
        <div class="session-card-header">
          <span class="session-number">{{ session.sessionNumber }}</span>
          <span :class="['session-status', session.status.toLowerCase()]">
            {{ getStatusText(session.status) }}
          </span>
        </div>
        
        <div class="session-card-body">
          <div class="guest-info">
            <strong>{{ session.guestInfo.primaryGuest.firstName }} {{ session.guestInfo.primaryGuest.lastName }}</strong>
            <span v-if="session.guestInfo.additionalGuests.length > 0">
              +{{ session.guestInfo.additionalGuests.length }}å
            </span>
          </div>
          
          <div class="room-info">
            éƒ¨å±‹: {{ session.room?.roomNumber }}
          </div>
          
          <div class="timing-info">
            <div>ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³: {{ formatDate(session.checkInAt) }}</div>
            <div>äºˆå®šãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ: {{ formatDate(session.plannedCheckOut) }}</div>
          </div>
          
          <div class="billing-info" v-if="session.billings?.[0]">
            <span>è«‹æ±‚é¡: Â¥{{ session.billings[0].totalAmount.toLocaleString() }}</span>
            <span>æ”¯æ‰•æ¸ˆ: Â¥{{ session.billings[0].paidAmount.toLocaleString() }}</span>
          </div>
        </div>
        
        <div class="session-card-actions">
          <button @click.stop="viewOrders(session)">æ³¨æ–‡å±¥æ­´</button>
          <button @click.stop="viewBilling(session)">è«‹æ±‚è©³ç´°</button>
          <button 
            v-if="canCheckout(session)"
            @click.stop="initiateCheckout(session)"
            class="checkout-btn"
          >
            ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
          </button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { CheckinSession } from '~/types/checkin-session'

const { searchSessions } = useSessionApi()

const sessions = ref<CheckinSession[]>([])
const loading = ref(false)

const todayCheckouts = computed(() => {
  const today = new Date().toDateString()
  return sessions.value.filter(s => 
    new Date(s.plannedCheckOut).toDateString() === today
  ).length
})

const loadActiveSessions = async () => {
  loading.value = true
  try {
    sessions.value = await searchSessions({
      status: 'ACTIVE',
      limit: 100
    })
  } catch (error) {
    console.error('Failed to load sessions:', error)
  } finally {
    loading.value = false
  }
}

const getStatusText = (status: string) => {
  const statusMap = {
    'ACTIVE': 'æ»åœ¨ä¸­',
    'EXTENDED': 'å»¶æ³Šä¸­',
    'CHECKED_OUT': 'ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆæ¸ˆã¿',
    'CANCELED': 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«'
  }
  return statusMap[status] || status
}

const canCheckout = (session: CheckinSession) => {
  return session.status === 'ACTIVE' || session.status === 'EXTENDED'
}

const selectSession = (session: CheckinSession) => {
  // ã‚»ãƒƒã‚·ãƒ§ãƒ³è©³ç´°ç”»é¢ã¸é·ç§»
  navigateTo(`/sessions/${session.id}`)
}

const viewOrders = (session: CheckinSession) => {
  // æ³¨æ–‡å±¥æ­´ç”»é¢ã¸é·ç§»
  navigateTo(`/sessions/${session.id}/orders`)
}

const viewBilling = (session: CheckinSession) => {
  // è«‹æ±‚è©³ç´°ç”»é¢ã¸é·ç§»
  navigateTo(`/sessions/${session.id}/billing`)
}

const initiateCheckout = (session: CheckinSession) => {
  // ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆå‡¦ç†ç”»é¢ã¸é·ç§»
  navigateTo(`/sessions/${session.id}/checkout`)
}

const formatDate = (date: Date) => {
  return new Intl.DateTimeFormat('ja-JP', {
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  }).format(new Date(date))
}

onMounted(() => {
  loadActiveSessions()
})

// å®šæœŸçš„ãªæ›´æ–°
const refreshInterval = setInterval(loadActiveSessions, 30000) // 30ç§’ã”ã¨

onUnmounted(() => {
  clearInterval(refreshInterval)
})
</script>
```

---

## ğŸ”§ **APIçµ±åˆ**

### **1. PMS APIæ‹¡å¼µ**

```typescript
// /api/pms/* ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆç¾¤ã®æ‹¡å¼µ

interface PmsApiExtension {
  // ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³å‡¦ç†
  'POST /api/pms/checkin': {
    body: CheckinProcessRequest;
    response: {
      session: CheckinSession;
      billing: SessionBilling;
    };
  };
  
  // ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆå‡¦ç†
  'POST /api/pms/checkout': {
    body: CheckoutProcessRequest;
    response: {
      session: CheckinSession;
      finalBilling: SessionBilling;
    };
  };
  
  // ã‚»ãƒƒã‚·ãƒ§ãƒ³å»¶æ³Šå‡¦ç†
  'POST /api/pms/sessions/:sessionId/extend': {
    body: {
      newCheckOutDate: Date;
      additionalNights: number;
      notes?: string;
    };
    response: CheckinSession;
  };
  
  // éƒ¨å±‹çŠ¶æ³å–å¾—ï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³æƒ…å ±å«ã‚€ï¼‰
  'GET /api/pms/rooms/status': {
    query: {
      floor?: number;
      roomType?: string;
      date?: string;
    };
    response: Array<{
      room: Room;
      activeSession?: CheckinSession;
      nextReservation?: Reservation;
      status: RoomStatus;
    }>;
  };
}
```

### **2. GraphQLçµ±åˆ**

```graphql
# ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ç”¨GraphQLã‚¹ã‚­ãƒ¼ãƒæ‹¡å¼µ

type CheckinSession {
  id: ID!
  sessionNumber: String!
  reservation: Reservation!
  room: Room!
  customer: Customer!
  guestInfo: GuestInfo!
  checkInAt: DateTime!
  checkOutAt: DateTime
  plannedCheckOut: DateTime!
  status: SessionStatus!
  serviceOrders: [ServiceOrder!]!
  billings: [SessionBilling!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type GuestInfo {
  primaryGuest: PrimaryGuest!
  additionalGuests: [AdditionalGuest!]!
  specialNeeds: [String!]
  preferences: JSON
}

type SessionBilling {
  id: ID!
  sessionNumber: String!
  billingNumber: String!
  roomCharges: [RoomCharge!]!
  serviceCharges: [ServiceCharge!]!
  taxes: [TaxDetail!]!
  discounts: [DiscountDetail!]!
  subtotalAmount: Float!
  taxAmount: Float!
  totalAmount: Float!
  paidAmount: Float!
  status: BillingStatus!
  paymentMethod: PaymentMethod
  paymentDate: DateTime
  dueDate: DateTime
}

extend type Query {
  # ã‚»ãƒƒã‚·ãƒ§ãƒ³å–å¾—
  session(id: ID!): CheckinSession
  sessionByNumber(sessionNumber: String!): CheckinSession
  activeSessionByRoom(roomId: ID!): CheckinSession
  
  # ã‚»ãƒƒã‚·ãƒ§ãƒ³æ¤œç´¢
  sessions(
    status: SessionStatus
    roomId: ID
    customerId: ID
    checkInDateFrom: DateTime
    checkInDateTo: DateTime
    limit: Int = 50
    offset: Int = 0
  ): [CheckinSession!]!
  
  # ã‚»ãƒƒã‚·ãƒ§ãƒ³çµ±è¨ˆ
  sessionStats(
    dateFrom: DateTime!
    dateTo: DateTime!
  ): SessionStats!
}

extend type Mutation {
  # ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³å‡¦ç†
  processCheckin(input: CheckinProcessInput!): CheckinProcessResult!
  
  # ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆå‡¦ç†
  processCheckout(input: CheckoutProcessInput!): CheckoutProcessResult!
  
  # ã‚»ãƒƒã‚·ãƒ§ãƒ³å»¶æ³Š
  extendSession(
    sessionId: ID!
    newCheckOutDate: DateTime!
    additionalNights: Int!
  ): CheckinSession!
  
  # ã‚»ãƒƒã‚·ãƒ§ãƒ³æ›´æ–°
  updateSession(
    sessionId: ID!
    input: UpdateSessionInput!
  ): CheckinSession!
}

extend type Subscription {
  # ã‚»ãƒƒã‚·ãƒ§ãƒ³çŠ¶æ…‹å¤‰æ›´
  sessionUpdated(sessionId: ID): CheckinSession!
  
  # æ–°è¦ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆ
  sessionCreated: CheckinSession!
  
  # ã‚»ãƒƒã‚·ãƒ§ãƒ³è«‹æ±‚æ›´æ–°
  sessionBillingUpdated(sessionId: ID): SessionBilling!
}
```

---

## ğŸ“Š **ãƒ¬ãƒãƒ¼ãƒˆæ©Ÿèƒ½çµ±åˆ**

### **1. ã‚»ãƒƒã‚·ãƒ§ãƒ³å˜ä½ãƒ¬ãƒãƒ¼ãƒˆ**

```typescript
interface SessionReportService {
  // æ—¥æ¬¡ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ¬ãƒãƒ¼ãƒˆ
  generateDailySessionReport(date: Date): Promise<{
    totalSessions: number;
    activeSessionsStart: number;
    activeSessionsEnd: number;
    checkins: number;
    checkouts: number;
    extensions: number;
    averageStayDuration: number;
    occupancyRate: number;
    revenue: {
      room: number;
      service: number;
      total: number;
    };
  }>;
  
  // ã‚»ãƒƒã‚·ãƒ§ãƒ³åç›Šåˆ†æ
  analyzeSessionRevenue(
    dateFrom: Date,
    dateTo: Date
  ): Promise<{
    totalRevenue: number;
    averageRevenuePerSession: number;
    roomRevenue: number;
    serviceRevenue: number;
    revenueByRoomType: Record<string, number>;
    revenueByServiceCategory: Record<string, number>;
  }>;
  
  // ã‚»ãƒƒã‚·ãƒ§ãƒ³æœŸé–“åˆ†æ
  analyzeSessionDuration(
    dateFrom: Date,
    dateTo: Date
  ): Promise<{
    averageDuration: number;
    durationDistribution: Record<string, number>;
    extensionRate: number;
    earlyCheckoutRate: number;
  }>;
}
```

---

## ğŸ§ª **ãƒ†ã‚¹ãƒˆæˆ¦ç•¥**

### **1. å˜ä½“ãƒ†ã‚¹ãƒˆ**

```typescript
// ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆãƒ†ã‚¹ãƒˆ
describe('Session Creation', () => {
  test('should create session with valid data', async () => {
    const request: CheckinProcessRequest = {
      reservationId: 'res-123',
      roomId: 'room-456',
      customerId: 'cust-789',
      guestInfo: mockGuestInfo,
      actualCheckInTime: new Date(),
      specialRequests: 'Late checkout'
    };
    
    const result = await processCheckin(request);
    
    expect(result.session).toBeDefined();
    expect(result.session.sessionNumber).toMatch(/^R\d+-\d{8}-\d{3}$/);
    expect(result.billing).toBeDefined();
  });
  
  test('should handle duplicate session creation', async () => {
    // é‡è¤‡ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆã®ãƒ†ã‚¹ãƒˆ
  });
});

// ã‚»ãƒƒã‚·ãƒ§ãƒ³è«‹æ±‚ãƒ†ã‚¹ãƒˆ
describe('Session Billing', () => {
  test('should calculate billing correctly', async () => {
    // è«‹æ±‚è¨ˆç®—ã®æ­£ç¢ºæ€§ãƒ†ã‚¹ãƒˆ
  });
  
  test('should handle service order additions', async () => {
    // ã‚µãƒ¼ãƒ“ã‚¹æ³¨æ–‡è¿½åŠ æ™‚ã®è«‹æ±‚æ›´æ–°ãƒ†ã‚¹ãƒˆ
  });
});
```

### **2. çµ±åˆãƒ†ã‚¹ãƒˆ**

```typescript
// ã‚·ã‚¹ãƒ†ãƒ é–“é€£æºãƒ†ã‚¹ãƒˆ
describe('System Integration', () => {
  test('should sync with hotel-saas orders', async () => {
    // hotel-saasã‹ã‚‰ã®æ³¨æ–‡ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†ãƒ†ã‚¹ãƒˆ
  });
  
  test('should sync with hotel-member points', async () => {
    // hotel-memberã¨ã®ãƒã‚¤ãƒ³ãƒˆé€£æºãƒ†ã‚¹ãƒˆ
  });
});
```

---

## ğŸ“… **å®Ÿè£…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«**

### **Week 1 (1/20-1/26)**
- [ ] ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒæ‹¡å¼µ
- [ ] åŸºæœ¬APIå®Ÿè£…ï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆãƒ»å–å¾—ï¼‰
- [ ] ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†å®Ÿè£…

### **Week 2 (1/27-2/2)**
- [ ] ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³ãƒ»ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆå‡¦ç†çµ±åˆ
- [ ] ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ç”»é¢å®Ÿè£…
- [ ] GraphQLçµ±åˆ

### **Week 3 (2/3-2/9)**
- [ ] ãƒ¬ãƒãƒ¼ãƒˆæ©Ÿèƒ½çµ±åˆ
- [ ] ãƒ†ã‚¹ãƒˆå®Ÿè£…ãƒ»å®Ÿè¡Œ
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

---

## ğŸ¯ **æˆåŠŸæŒ‡æ¨™**

### **æŠ€è¡“æŒ‡æ¨™**
- [ ] ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆæˆåŠŸç‡: 99.9%ä»¥ä¸Š
- [ ] ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³å‡¦ç†æ™‚é–“: < 30ç§’
- [ ] ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ã‚¨ãƒ©ãƒ¼: 0ä»¶

### **æ¥­å‹™æŒ‡æ¨™**
- [ ] ãƒ•ãƒ­ãƒ³ãƒˆæ¥­å‹™åŠ¹ç‡: 20%å‘ä¸Š
- [ ] è«‹æ±‚ã‚¨ãƒ©ãƒ¼: 90%å‰Šæ¸›
- [ ] é¡§å®¢æº€è¶³åº¦: å‘ä¸Š

---

**Lunaï¼ˆæœˆèª­ï¼‰ã¨ã—ã¦ã€å†·é™æ²ˆç€ã«ç¢ºå®Ÿãªå®Ÿè£…ã‚’é‚è¡Œã—ã€24æ™‚é–“ç„¡åœæ­¢é‹ç”¨ã‚’ç¶­æŒã—ãªãŒã‚‰ã‚·ã‚¹ãƒ†ãƒ ã®ä¿¡é ¼æ€§å‘ä¸Šã‚’å®Ÿç¾ã—ã¾ã™ã€‚**

---

**ä½œæˆè€…**: Lunaï¼ˆæœˆèª­ - Tsukuyomiï¼‰  
**æ‰¿èªè€…**: hotel-pmsãƒãƒ¼ãƒ è²¬ä»»è€…  
**é…å¸ƒå…ˆ**: hotel-pmsãƒãƒ¼ãƒ ã€é–¢é€£ã‚·ã‚¹ãƒ†ãƒ ãƒãƒ¼ãƒ 




