# âš¡ Sunoï¼ˆé ˆä½ä¹‹ç”·ï¼‰CRMå®Ÿè£…æŒ‡ç¤ºæ›¸
**Namiã‹ã‚‰ã®é©å‘½çš„CRMä»•æ§˜ â†’ hotel-memberæ‹¡å¼µå®Ÿè£…**

**æŒ‡ç¤ºè€…**: ğŸŒŠ Izaï¼ˆIzanagiçµ±åˆç®¡ç†è€…ï¼‰  
**å®Ÿè£…è€…**: âš¡ Sunoï¼ˆSusanooï¼‰hotel-memberå°‚é–€AI  
**ç·Šæ€¥åº¦**: ğŸš¨ CRITICAL  
**å®Ÿè£…æœŸé–“**: 9é€±é–“ï¼ˆPhase 1-3ï¼‰  
**äº‹æ¥­ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆ**: å¹´é–“Â¥213,840,000åç›Šï¼ˆå¾“æ¥æ¯”+103%ï¼‰

---

## ğŸ¯ **å®Ÿè£…æ¦‚è¦ãƒ»ç·Šæ€¥è¦è«‹**

### **ğŸ“‹ Sunoã®æ–°ãŸãªä½¿å‘½**
```typescript
interface SunoNewMission {
  å¾“æ¥ã®å½¹å‰²: "hotel-memberé¡§å®¢ç®¡ç†ãƒ»ä¼šå“¡ã‚·ã‚¹ãƒ†ãƒ å°‚é–€";
  æ–°ãŸãªä½¿å‘½: "AIé§†å‹•å‹CRMã‚·ã‚¹ãƒ†ãƒ ãƒ»AIã‚¯ãƒ¬ã‚¸ãƒƒãƒˆç®¡ç†çµ±åˆ";
  é©æ–°ä¾¡å€¤: "æ¥­ç•Œåˆã®AIã‚¯ãƒ¬ã‚¸ãƒƒãƒˆå¾“é‡èª²é‡‘åˆ¶CRM";
  å¸‚å ´ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆ: "æœˆÂ¥7,800ã‹ã‚‰å§‹ã‚ã‚‰ã‚Œã‚‹é©æ–°çš„ãƒ›ãƒ†ãƒ«CRM";
}
```

### **âš¡ ç·Šæ€¥å®Ÿè£…ãŒå¿…è¦ãªç†ç”±**
1. **ç¾å ´è¦æœ›å®Œå…¨é©åˆ**: æ£®è—¤ç´³ä»‹æ°ï¼ˆãƒ—ãƒ©ãƒ³ã‚¿ãƒ³ãƒ›ãƒ†ãƒ«ï¼‰è¦æœ›Â¥15,000ä»¥ä¸‹ã‚’Â¥7,800ã§ã‚¯ãƒªã‚¢
2. **å¸‚å ´æ©Ÿä¼šæœ€å¤§åŒ–**: ä¾¡æ ¼éšœå£å‰Šæ¸›ã§é¡§å®¢æ•°2.25å€å¢—åŠ è¦‹è¾¼ã¿
3. **ç«¶äº‰å„ªä½ç¢ºç«‹**: æ¥­ç•ŒåˆAIã‚¯ãƒ¬ã‚¸ãƒƒãƒˆåˆ¶ã§åœ§å€’çš„å·®åˆ¥åŒ–
4. **åç›Šæ€§ç¢ºä¿**: 103%ã®åç›Šå‘ä¸Šã§äº‹æ¥­åŸºç›¤å¼·åŒ–

---

## ğŸ’° **æ–°æ–™é‡‘ãƒ—ãƒ©ãƒ³ãƒ»äº‹æ¥­æˆ¦ç•¥**

### **ğŸ¯ ç¢ºå®šæ–™é‡‘ä½“ç³»**
```json
{
  "Essential": {
    "åŸºæœ¬æ–™é‡‘": "Â¥7,800/æœˆ",
    "ç„¡æ–™AIã‚¯ãƒ¬ã‚¸ãƒƒãƒˆ": 300,
    "å¯¾è±¡": "10-30å®¤å°è¦æ¨¡ãƒ¬ã‚¸ãƒ£ãƒ¼ãƒ›ãƒ†ãƒ«",
    "é©æ–°æ€§": "å¾“æ¥Â¥12,800ã‹ã‚‰38%å‰Šæ¸›"
  },
  "Professional": {
    "åŸºæœ¬æ–™é‡‘": "Â¥16,800/æœˆ", 
    "ç„¡æ–™AIã‚¯ãƒ¬ã‚¸ãƒƒãƒˆ": 1000,
    "å¯¾è±¡": "30-100å®¤ä¸­è¦æ¨¡ãƒ¬ã‚¸ãƒ£ãƒ¼ãƒ›ãƒ†ãƒ«",
    "ãƒ‘ã‚¤ãƒ­ãƒƒãƒˆ": "æ£®è—¤ç´³ä»‹æ°ï¼ˆãƒ—ãƒ©ãƒ³ã‚¿ãƒ³ãƒ›ãƒ†ãƒ«ï¼‰ç¢ºå®š"
  },
  "Enterprise": {
    "åŸºæœ¬æ–™é‡‘": "Â¥29,800/æœˆ",
    "ç„¡æ–™AIã‚¯ãƒ¬ã‚¸ãƒƒãƒˆ": 2000,
    "å¯¾è±¡": "100å®¤ä»¥ä¸Šãƒ»ãƒã‚§ãƒ¼ãƒ³ãƒ»ã‚°ãƒ«ãƒ¼ãƒ—",
    "å‰Šæ¸›åŠ¹æœ": "å¾“æ¥Â¥49,800ã‹ã‚‰40%å‰Šæ¸›"
  }
}
```

### **ğŸ’³ AIã‚¯ãƒ¬ã‚¸ãƒƒãƒˆä½“ç³»**
```json
{
  "è¿½åŠ è³¼å…¥ä¾¡æ ¼": {
    "Essential": "Â¥50/100ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆ",
    "Professional": "Â¥45/100ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆï¼ˆ10%å‰²å¼•ï¼‰",
    "Enterprise": "Â¥40/100ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆï¼ˆ20%å‰²å¼•ï¼‰"
  },
  "AIæ©Ÿèƒ½åˆ¥æ¶ˆè²»": {
    "ãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆ": "2ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆ/å›",
    "ãƒ¬ã‚³ãƒ¡ãƒ³ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³": "5ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆ/å›",
    "äºˆæ¸¬åˆ†æ": "8ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆ/å›",
    "é«˜åº¦åˆ†æ": "10ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆ/å›"
  }
}
```

---

## ğŸ—„ï¸ **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ‹¡å¼µå®Ÿè£…**

### **ğŸ†• æ–°è¦ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆï¼ˆæœ€å„ªå…ˆï¼‰**

#### **1. ai_credit_accountsï¼ˆAIã‚¯ãƒ¬ã‚¸ãƒƒãƒˆã‚¢ã‚«ã‚¦ãƒ³ãƒˆï¼‰**
```sql
-- FastAPI/SQLAlchemyå¯¾å¿œ
CREATE TABLE ai_credit_accounts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  
  -- ãƒ—ãƒ©ãƒ³æƒ…å ±
  plan_type VARCHAR(20) NOT NULL CHECK (plan_type IN ('ESSENTIAL', 'PROFESSIONAL', 'ENTERPRISE')),
  monthly_free_credits INTEGER NOT NULL,
  
  -- ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆæ®‹é«˜
  current_balance INTEGER NOT NULL DEFAULT 0,
  total_purchased_credits INTEGER DEFAULT 0,
  total_used_credits INTEGER DEFAULT 0,
  
  -- è‡ªå‹•è³¼å…¥è¨­å®š
  auto_purchase_enabled BOOLEAN DEFAULT false,
  auto_purchase_threshold INTEGER DEFAULT 50,
  auto_purchase_amount INTEGER DEFAULT 500,
  
  -- ç›£æŸ»ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  deleted_at TIMESTAMP,
  
  -- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æœ€é©åŒ–
  INDEX idx_tenant_plan (tenant_id, plan_type),
  INDEX idx_balance (current_balance),
  INDEX idx_auto_purchase (auto_purchase_enabled, auto_purchase_threshold)
);
```

#### **2. ai_credit_transactionsï¼ˆã‚¯ãƒ¬ã‚¸ãƒƒãƒˆå–å¼•å±¥æ­´ï¼‰**
```sql
CREATE TABLE ai_credit_transactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  account_id UUID NOT NULL REFERENCES ai_credit_accounts(id) ON DELETE CASCADE,
  
  -- å–å¼•è©³ç´°
  transaction_type VARCHAR(20) NOT NULL CHECK (transaction_type IN ('USAGE', 'PURCHASE', 'MONTHLY_RESET', 'BONUS', 'REFUND')),
  credits_amount INTEGER NOT NULL,
  
  -- AIæ©Ÿèƒ½è©³ç´°
  ai_function_type VARCHAR(50),
  ai_function_params JSON,
  execution_time_ms INTEGER,
  
  -- æ–™é‡‘æƒ…å ±
  cost_per_credit DECIMAL(4,2),
  total_cost_yen INTEGER,
  
  -- é–¢é€£æƒ…å ±
  user_id UUID REFERENCES users(id),
  description TEXT,
  reference_id UUID,
  
  -- ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
  created_at TIMESTAMP DEFAULT NOW(),
  
  -- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
  INDEX idx_account_date (account_id, created_at),
  INDEX idx_function_type (ai_function_type),
  INDEX idx_user_date (user_id, created_at)
);
```

#### **3. ai_credit_packagesï¼ˆã‚¯ãƒ¬ã‚¸ãƒƒãƒˆãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ï¼‰**
```sql
CREATE TABLE ai_credit_packages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸æƒ…å ±
  plan_type VARCHAR(20) NOT NULL,
  credits_amount INTEGER NOT NULL,
  price_yen INTEGER NOT NULL,
  discount_rate DECIMAL(5,2) DEFAULT 0,
  
  -- åˆ†é¡ãƒ»åˆ¶å¾¡
  is_bulk_package BOOLEAN DEFAULT false,
  is_promotional BOOLEAN DEFAULT false,
  active BOOLEAN DEFAULT true,
  
  -- è¡¨ç¤ºãƒ»èª¬æ˜
  display_name VARCHAR(100),
  description TEXT,
  marketing_highlight TEXT,
  
  -- æœ‰åŠ¹æœŸé™
  valid_from DATE DEFAULT CURRENT_DATE,
  valid_until DATE,
  
  -- ç›£æŸ»
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  INDEX idx_plan_active (plan_type, active)
);
```

#### **4. monthly_credit_resetsï¼ˆæœˆæ¬¡ãƒªã‚»ãƒƒãƒˆç®¡ç†ï¼‰**
```sql
CREATE TABLE monthly_credit_resets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  account_id UUID NOT NULL REFERENCES ai_credit_accounts(id) ON DELETE CASCADE,
  
  -- ãƒªã‚»ãƒƒãƒˆæƒ…å ±
  reset_date DATE NOT NULL,
  previous_balance INTEGER NOT NULL,
  free_credits_added INTEGER NOT NULL,
  carried_over_credits INTEGER DEFAULT 0,
  
  -- çµ±è¨ˆæƒ…å ±
  total_usage_previous_month INTEGER DEFAULT 0,
  most_used_function VARCHAR(50),
  efficiency_score DECIMAL(5,2),
  
  created_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE (account_id, reset_date)
);
```

### **ğŸ”§ æ—¢å­˜ãƒ†ãƒ¼ãƒ–ãƒ«æ‹¡å¼µ**
```sql
-- usersãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆé¡§å®¢ç®¡ç†æ‹¡å¼µï¼‰
ALTER TABLE users ADD COLUMN crm_plan_type VARCHAR(20) DEFAULT 'ESSENTIAL';
ALTER TABLE users ADD COLUMN crm_activated_at TIMESTAMP;
ALTER TABLE users ADD COLUMN ai_usage_preferences JSON DEFAULT '{}';

-- tenantsãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆãƒ›ãƒ†ãƒ«ç®¡ç†æ‹¡å¼µï¼‰
ALTER TABLE tenants ADD COLUMN billing_email VARCHAR(255);
ALTER TABLE tenants ADD COLUMN stripe_customer_id VARCHAR(100);
ALTER TABLE tenants ADD COLUMN crm_features_enabled JSON DEFAULT '{}';
```

---

## ğŸ”Œ **FastAPI ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå®Ÿè£…**

### **ğŸ“Š ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆç®¡ç†API**

#### **æ®‹é«˜ãƒ»ã‚¢ã‚«ã‚¦ãƒ³ãƒˆæƒ…å ±API**
```python
# app/api/credits.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.database import get_db
from app.models.ai_credit import AICreditAccount, AICreditTransaction
from app.schemas.credit import CreditBalanceResponse, CreditUsageRequest

router = APIRouter(prefix="/api/v1/credits", tags=["credits"])

@router.get("/balance", response_model=CreditBalanceResponse)
async def get_credit_balance(
    tenant_id: str = Depends(get_current_tenant_id),
    db: Session = Depends(get_db)
):
    """
    ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆæ®‹é«˜ãƒ»ä½¿ç”¨çŠ¶æ³å–å¾—
    """
    account = db.query(AICreditAccount).filter(
        AICreditAccount.tenant_id == tenant_id
    ).first()
    
    if not account:
        # åˆå›ã‚¢ã‚«ã‚¦ãƒ³ãƒˆä½œæˆ
        account = await create_default_account(tenant_id, db)
    
    # ä»Šæœˆã®ä½¿ç”¨é‡è¨ˆç®—
    current_month = datetime.now().replace(day=1, hour=0, minute=0, second=0)
    monthly_usage = db.query(func.sum(AICreditTransaction.credits_amount)).filter(
        AICreditTransaction.account_id == account.id,
        AICreditTransaction.created_at >= current_month,
        AICreditTransaction.transaction_type == 'USAGE'
    ).scalar() or 0
    
    # æ©Ÿèƒ½åˆ¥ä½¿ç”¨é‡çµ±è¨ˆ
    function_usage = db.query(
        AICreditTransaction.ai_function_type,
        func.sum(func.abs(AICreditTransaction.credits_amount)).label('total_usage'),
        func.count(AICreditTransaction.id).label('usage_count')
    ).filter(
        AICreditTransaction.account_id == account.id,
        AICreditTransaction.transaction_type == 'USAGE',
        AICreditTransaction.created_at >= current_month
    ).group_by(AICreditTransaction.ai_function_type).all()
    
    return CreditBalanceResponse(
        account={
            "account_id": account.id,
            "tenant_id": account.tenant_id,
            "plan_type": account.plan_type
        },
        balance={
            "current_balance": account.current_balance,
            "monthly_free_credits": account.monthly_free_credits,
            "used_this_month": abs(monthly_usage),
            "total_purchased": account.total_purchased_credits,
            "estimated_days_left": calculate_estimated_days(account, monthly_usage)
        },
        auto_purchase={
            "enabled": account.auto_purchase_enabled,
            "threshold": account.auto_purchase_threshold,
            "purchase_amount": account.auto_purchase_amount
        },
        usage={
            "top_functions": [
                {
                    "function_type": usage.ai_function_type,
                    "credits_used": usage.total_usage,
                    "usage_count": usage.usage_count,
                    "percentage": (usage.total_usage / abs(monthly_usage)) * 100 if monthly_usage else 0
                }
                for usage in function_usage
            ]
        }
    )

async def create_default_account(tenant_id: str, db: Session) -> AICreditAccount:
    """ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ã‚«ã‚¦ãƒ³ãƒˆä½œæˆ"""
    tenant = db.query(Tenant).filter(Tenant.id == tenant_id).first()
    default_plan = tenant.crm_plan_type if tenant else 'ESSENTIAL'
    
    account = AICreditAccount(
        tenant_id=tenant_id,
        plan_type=default_plan,
        monthly_free_credits=get_free_credits_by_plan(default_plan),
        current_balance=get_free_credits_by_plan(default_plan)
    )
    
    db.add(account)
    db.commit()
    db.refresh(account)
    
    return account

def get_free_credits_by_plan(plan_type: str) -> int:
    """ãƒ—ãƒ©ãƒ³åˆ¥ç„¡æ–™ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆæ•°"""
    return {
        'ESSENTIAL': 300,
        'PROFESSIONAL': 1000,
        'ENTERPRISE': 2000
    }.get(plan_type, 300)
```

#### **AIæ©Ÿèƒ½å®Ÿè¡ŒAPI**
```python
@router.post("/ai/execute", response_model=AIExecutionResponse)
async def execute_ai_function(
    request: AIExecutionRequest,
    tenant_id: str = Depends(get_current_tenant_id),
    user_id: str = Depends(get_current_user_id),
    db: Session = Depends(get_db)
):
    """
    AIæ©Ÿèƒ½å®Ÿè¡Œãƒ»ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆæ¶ˆè²»å‡¦ç†
    """
    # ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆæ®‹é«˜ç¢ºèª
    account = await get_account(tenant_id, db)
    required_credits = get_function_credit_cost(request.function_type)
    
    if account.current_balance < required_credits:
        # è‡ªå‹•è³¼å…¥ãƒã‚§ãƒƒã‚¯
        if (account.auto_purchase_enabled and 
            account.current_balance <= account.auto_purchase_threshold):
            try:
                await execute_auto_purchase(account, db)
                # å†åº¦æ®‹é«˜ç¢ºèª
                db.refresh(account)
                if account.current_balance < required_credits:
                    raise HTTPException(
                        status_code=402, 
                        detail="ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆæ®‹é«˜ä¸è¶³ã€‚è¿½åŠ è³¼å…¥ãŒå¿…è¦ã§ã™ã€‚"
                    )
            except Exception as e:
                raise HTTPException(
                    status_code=402,
                    detail=f"è‡ªå‹•è³¼å…¥ã«å¤±æ•—ã—ã¾ã—ãŸ: {str(e)}"
                )
        else:
            raise HTTPException(
                status_code=402,
                detail=f"ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆæ®‹é«˜ä¸è¶³ã€‚{required_credits}ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆãŒå¿…è¦ã§ã™ã€‚"
            )
    
    # AIæ©Ÿèƒ½å®Ÿè¡Œ
    start_time = time.time()
    
    try:
        if request.function_type == 'CHATBOT':
            result = await execute_chatbot(request.parameters)
        elif request.function_type == 'RECOMMENDATION':
            result = await execute_recommendation(request.parameters, tenant_id)
        elif request.function_type == 'PREDICTION':
            result = await execute_prediction(request.parameters, tenant_id)
        elif request.function_type == 'ANALYSIS':
            result = await execute_analysis(request.parameters, tenant_id)
        else:
            raise HTTPException(status_code=400, detail="Unsupported function type")
        
        execution_time = int((time.time() - start_time) * 1000)
        
        # å®Ÿéš›ã®ä½¿ç”¨é‡ã«åŸºã¥ãã‚¯ãƒ¬ã‚¸ãƒƒãƒˆè¨ˆç®—
        actual_credits = calculate_actual_credits(
            request.function_type, 
            result, 
            execution_time
        )
        
        # ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆæ¶ˆè²»è¨˜éŒ²
        transaction = await consume_credits(
            account_id=account.id,
            credits_amount=actual_credits,
            function_type=request.function_type,
            function_params=request.parameters,
            execution_time=execution_time,
            user_id=user_id,
            db=db
        )
        
        return AIExecutionResponse(
            execution={
                "execution_id": str(transaction.id),
                "function_type": request.function_type,
                "execution_time": execution_time,
                "timestamp": datetime.now().isoformat()
            },
            result={
                "output": result.output,
                "confidence": result.confidence,
                "additional_data": result.additional_data
            },
            credits={
                "credits_used": actual_credits,
                "remaining_balance": account.current_balance - actual_credits,
                "cost_per_credit": get_cost_per_credit(account.plan_type),
                "total_cost": actual_credits * get_cost_per_credit(account.plan_type)
            },
            billing={
                "transaction_id": str(transaction.id),
                "billable_units": actual_credits
            }
        )
        
    except Exception as e:
        # ã‚¨ãƒ©ãƒ¼æ™‚ã®éƒ¨åˆ†ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆæ¶ˆè²»
        await handle_execution_error(account.id, e, request, db)
        raise HTTPException(status_code=500, detail=f"AIæ©Ÿèƒ½å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {str(e)}")

def get_function_credit_cost(function_type: str) -> int:
    """æ©Ÿèƒ½åˆ¥ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆã‚³ã‚¹ãƒˆ"""
    return {
        'CHATBOT': 2,
        'RECOMMENDATION': 5,
        'PREDICTION': 8,
        'ANALYSIS': 10,
        'CUSTOM': 15
    }.get(function_type, 5)
```

### **ğŸ’³ Stripeæ±ºæ¸ˆçµ±åˆAPI**

#### **ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆè³¼å…¥API**
```python
# app/api/payments.py
import stripe
from app.core.config import settings

stripe.api_key = settings.STRIPE_SECRET_KEY

@router.post("/credits/purchase", response_model=PurchaseResponse)
async def purchase_credits(
    request: PurchaseCreditRequest,
    tenant_id: str = Depends(get_current_tenant_id),
    db: Session = Depends(get_db)
):
    """
    ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆè³¼å…¥ãƒ»Stripeæ±ºæ¸ˆå‡¦ç†
    """
    account = await get_account(tenant_id, db)
    package = db.query(AICreditPackage).filter(
        AICreditPackage.id == request.package_id,
        AICreditPackage.active == True
    ).first()
    
    if not package:
        raise HTTPException(status_code=404, detail="ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
    
    try:
        if request.payment_method == 'stripe':
            # Stripeæ±ºæ¸ˆå‡¦ç†
            payment_intent = stripe.PaymentIntent.create(
                amount=package.price_yen * 100,  # å††ã‚’centsã«å¤‰æ›
                currency='jpy',
                payment_method=request.payment_details.stripe_payment_method_id,
                confirmation_method='manual',
                confirm=True,
                metadata={
                    'account_id': str(account.id),
                    'tenant_id': tenant_id,
                    'package_id': str(package.id),
                    'credits_amount': str(package.credits_amount)
                }
            )
            
            if payment_intent.status == 'succeeded':
                # ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆä»˜ä¸
                await add_credits(
                    account_id=account.id,
                    credits_amount=package.credits_amount,
                    transaction_type='PURCHASE',
                    payment_reference=payment_intent.id,
                    description=f"Package purchase: {package.display_name}",
                    db=db
                )
                
                return PurchaseResponse(
                    purchase={
                        "transaction_id": payment_intent.id,
                        "package_id": str(package.id),
                        "credits_added": package.credits_amount,
                        "total_cost": package.price_yen,
                        "discount": calculate_discount(package)
                    },
                    payment={
                        "payment_status": "completed",
                        "payment_intent_id": payment_intent.id
                    },
                    account={
                        "new_balance": account.current_balance + package.credits_amount,
                        "estimated_days_left": calculate_estimated_days_after_purchase(
                            account, package.credits_amount
                        )
                    }
                )
            
            elif payment_intent.status == 'requires_action':
                return PurchaseResponse(
                    payment={
                        "payment_status": "requires_action",
                        "payment_intent_id": payment_intent.id,
                        "client_secret": payment_intent.client_secret
                    }
                )
            
            else:
                raise HTTPException(
                    status_code=402,
                    detail=f"æ±ºæ¸ˆã«å¤±æ•—ã—ã¾ã—ãŸ: {payment_intent.status}"
                )
                
        elif request.payment_method == 'invoice':
            # ä¼æ¥­å‘ã‘è«‹æ±‚æ›¸æ‰•ã„
            await create_invoice_request(account, package, request, db)
            
            return PurchaseResponse(
                payment={
                    "payment_status": "pending",
                    "message": "è«‹æ±‚æ›¸ã‚’ç™ºè¡Œã—ã¾ã—ãŸã€‚ãŠæ”¯æ‰•ã„å¾Œã«ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆãŒä»˜ä¸ã•ã‚Œã¾ã™ã€‚"
                }
            )
            
    except stripe.error.StripeError as e:
        await log_payment_error(account.id, package.id, str(e), db)
        raise HTTPException(status_code=402, detail=f"æ±ºæ¸ˆã‚¨ãƒ©ãƒ¼: {str(e)}")

async def add_credits(
    account_id: str,
    credits_amount: int,
    transaction_type: str,
    payment_reference: str,
    description: str,
    db: Session
):
    """ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆä»˜ä¸å‡¦ç†"""
    async with db.begin():
        # ã‚¢ã‚«ã‚¦ãƒ³ãƒˆæ®‹é«˜æ›´æ–°
        account = db.query(AICreditAccount).filter(
            AICreditAccount.id == account_id
        ).with_for_update().first()
        
        account.current_balance += credits_amount
        account.total_purchased_credits += credits_amount
        account.updated_at = datetime.now()
        
        # å–å¼•å±¥æ­´è¨˜éŒ²
        transaction = AICreditTransaction(
            account_id=account_id,
            transaction_type=transaction_type,
            credits_amount=credits_amount,
            description=description,
            reference_id=payment_reference
        )
        
        db.add(transaction)
        db.commit()
```

---

## ğŸ¤– **AIæ©Ÿèƒ½çµ±åˆå®Ÿè£…**

### **ğŸ§  OpenAIçµ±åˆã‚µãƒ¼ãƒ“ã‚¹**

#### **ãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆæ©Ÿèƒ½**
```python
# app/services/ai_functions.py
import openai
from app.core.config import settings

openai.api_key = settings.OPENAI_API_KEY

class AIFunctionService:
    
    async def execute_chatbot(self, parameters: dict) -> AIResult:
        """
        ãƒ›ãƒ†ãƒ«ç‰¹åŒ–ãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆæ©Ÿèƒ½
        """
        messages = [
            {
                "role": "system",
                "content": """ã‚ãªãŸã¯ãƒ›ãƒ†ãƒ«æ¥­ç•Œå°‚é–€ã®AIã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚
                ãƒ›ãƒ†ãƒ«é‹å–¶ã€é¡§å®¢ã‚µãƒ¼ãƒ“ã‚¹ã€äºˆç´„ç®¡ç†ã«é–¢ã™ã‚‹è³ªå•ã«å°‚é–€çš„ã«å›ç­”ã—ã¦ãã ã•ã„ã€‚
                å¸¸ã«ä¸å¯§ã§å®Ÿç”¨çš„ãªã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’æä¾›ã—ã€å…·ä½“çš„ãªè§£æ±ºç­–ã‚’ç¤ºã—ã¦ãã ã•ã„ã€‚"""
            },
            {
                "role": "user",
                "content": parameters.get('input', '')
            }
        ]
        
        try:
            response = await openai.ChatCompletion.acreate(
                model=parameters.get('model', 'gpt-4o-mini'),
                messages=messages,
                temperature=parameters.get('temperature', 0.7),
                max_tokens=parameters.get('max_tokens', 1000),
                presence_penalty=0.1,
                frequency_penalty=0.1
            )
            
            return AIResult(
                output=response.choices[0].message.content,
                confidence=calculate_confidence(response),
                execution_tokens=response.usage.total_tokens,
                additional_data={
                    "model_used": response.model,
                    "usage": response.usage._asdict()
                }
            )
            
        except Exception as e:
            raise AIExecutionError(f"ãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {str(e)}")
    
    async def execute_recommendation(self, parameters: dict, tenant_id: str) -> AIResult:
        """
        é¡§å®¢æ¨è–¦ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå”èª¿ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚° + AIï¼‰
        """
        customer_id = parameters.get('customer_id')
        recommendation_type = parameters.get('type', 'service')  # service, room, amenity
        
        # é¡§å®¢ãƒ‡ãƒ¼ã‚¿å–å¾—
        customer_data = await self.get_customer_profile(customer_id, tenant_id)
        similar_customers = await self.find_similar_customers(customer_data, tenant_id)
        
        # AIæ¨è–¦ç”Ÿæˆ
        prompt = f"""
        ãƒ›ãƒ†ãƒ«é¡§å®¢æ¨è–¦ã‚·ã‚¹ãƒ†ãƒ ã¨ã—ã¦ã€ä»¥ä¸‹ã®æƒ…å ±ã‚’åŸºã«æœ€é©ãªæ¨è–¦ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ï¼š
        
        é¡§å®¢ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«:
        - å¹´é½¢å±¤: {customer_data.get('age_group')}
        - å®¿æ³Šå±¥æ­´: {customer_data.get('stay_history')}
        - åˆ©ç”¨ã‚µãƒ¼ãƒ“ã‚¹: {customer_data.get('service_history')}
        - äºˆç®—å‚¾å‘: {customer_data.get('budget_range')}
        
        é¡ä¼¼é¡§å®¢ã®å‚¾å‘:
        {similar_customers}
        
        æ¨è–¦ã‚¿ã‚¤ãƒ—: {recommendation_type}
        
        å…·ä½“çš„ã§å®Ÿç”¨çš„ãªæ¨è–¦ã‚’3ã¤æä¾›ã—ã¦ãã ã•ã„ã€‚å„æ¨è–¦ã«ã¯ç†ç”±ã‚‚å«ã‚ã¦ãã ã•ã„ã€‚
        """
        
        response = await openai.ChatCompletion.acreate(
            model="gpt-4o",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.3,
            max_tokens=800
        )
        
        # æ¨è–¦çµæœã®æ§‹é€ åŒ–
        recommendations = self.parse_recommendations(response.choices[0].message.content)
        
        return AIResult(
            output=response.choices[0].message.content,
            confidence=0.85,
            additional_data={
                "recommendations": recommendations,
                "customer_segment": customer_data.get('segment'),
                "similarity_score": similar_customers.get('similarity_score')
            }
        )
    
    async def execute_prediction(self, parameters: dict, tenant_id: str) -> AIResult:
        """
        äºˆæ¸¬åˆ†ææ©Ÿèƒ½ï¼ˆéœ€è¦äºˆæ¸¬ãƒ»å£²ä¸Šäºˆæ¸¬ãƒ»ç¨¼åƒç‡äºˆæ¸¬ï¼‰
        """
        prediction_type = parameters.get('type')  # demand, revenue, occupancy
        time_horizon = parameters.get('horizon', 30)  # äºˆæ¸¬æ—¥æ•°
        
        # å±¥æ­´ãƒ‡ãƒ¼ã‚¿å–å¾—
        historical_data = await self.get_historical_data(tenant_id, prediction_type)
        external_factors = await self.get_external_factors(tenant_id)
        
        # æ©Ÿæ¢°å­¦ç¿’äºˆæ¸¬ + AIè§£é‡ˆ
        if prediction_type == 'demand':
            prediction_result = await self.predict_demand(
                historical_data, external_factors, time_horizon
            )
        elif prediction_type == 'revenue':
            prediction_result = await self.predict_revenue(
                historical_data, external_factors, time_horizon
            )
        elif prediction_type == 'occupancy':
            prediction_result = await self.predict_occupancy(
                historical_data, external_factors, time_horizon
            )
        
        # AI ã«ã‚ˆã‚‹äºˆæ¸¬è§£é‡ˆãƒ»ææ¡ˆç”Ÿæˆ
        interpretation_prompt = f"""
        ãƒ›ãƒ†ãƒ«çµŒå–¶åˆ†æå°‚é–€å®¶ã¨ã—ã¦ã€ä»¥ä¸‹ã®äºˆæ¸¬çµæœã‚’åˆ†æã—ã€
        å®Ÿç”¨çš„ãªçµŒå–¶åˆ¤æ–­ã®ãŸã‚ã®ã‚¤ãƒ³ã‚µã‚¤ãƒˆã‚’æä¾›ã—ã¦ãã ã•ã„ï¼š
        
        äºˆæ¸¬ã‚¿ã‚¤ãƒ—: {prediction_type}
        äºˆæ¸¬æœŸé–“: {time_horizon}æ—¥
        äºˆæ¸¬çµæœ: {prediction_result}
        
        ä»¥ä¸‹ã‚’å«ã‚ã¦åˆ†æã—ã¦ãã ã•ã„ï¼š
        1. äºˆæ¸¬çµæœã®è¦ç‚¹
        2. ãƒ“ã‚¸ãƒã‚¹ã¸ã®å½±éŸ¿
        3. æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
        4. ãƒªã‚¹ã‚¯è¦å› 
        """
        
        interpretation = await openai.ChatCompletion.acreate(
            model="gpt-4o",
            messages=[{"role": "user", "content": interpretation_prompt}],
            temperature=0.2,
            max_tokens=1000
        )
        
        return AIResult(
            output=interpretation.choices[0].message.content,
            confidence=prediction_result.get('confidence', 0.75),
            additional_data={
                "prediction_data": prediction_result,
                "forecast_accuracy": prediction_result.get('accuracy_score'),
                "key_factors": prediction_result.get('influencing_factors')
            }
        )

    async def predict_demand(self, historical_data: dict, external_factors: dict, horizon: int) -> dict:
        """éœ€è¦äºˆæ¸¬ï¼ˆæ™‚ç³»åˆ—åˆ†æ + å¤–éƒ¨è¦å› ï¼‰"""
        # ç°¡ç•¥åŒ–ã•ã‚ŒãŸäºˆæ¸¬ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆå®Ÿéš›ã¯æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ‡ãƒ«ä½¿ç”¨ï¼‰
        import numpy as np
        from sklearn.linear_model import LinearRegression
        
        # ç‰¹å¾´é‡ä½œæˆ
        features = self.create_demand_features(historical_data, external_factors)
        
        # äºˆæ¸¬ãƒ¢ãƒ‡ãƒ«å®Ÿè¡Œ
        model = LinearRegression()
        X_train, y_train = features['X_train'], features['y_train']
        model.fit(X_train, y_train)
        
        # æœªæ¥ã®äºˆæ¸¬
        X_future = features['X_future']
        predictions = model.predict(X_future)
        
        return {
            "predictions": predictions.tolist(),
            "confidence": model.score(X_train, y_train),
            "influencing_factors": features['feature_importance'],
            "trend": "increasing" if predictions[-1] > predictions[0] else "decreasing"
        }
```

### **ğŸ“Š çµ±è¨ˆãƒ»åˆ†ææ©Ÿèƒ½**
```python
class AnalyticsService:
    
    async def execute_analysis(self, parameters: dict, tenant_id: str) -> AIResult:
        """
        é«˜åº¦åˆ†ææ©Ÿèƒ½ï¼ˆé¡§å®¢ã‚»ã‚°ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»åç›Šåˆ†æãƒ»ç«¶åˆåˆ†æï¼‰
        """
        analysis_type = parameters.get('type')
        period = parameters.get('period', '3months')
        
        if analysis_type == 'customer_segmentation':
            return await self.customer_segmentation_analysis(tenant_id, period)
        elif analysis_type == 'revenue_analysis':
            return await self.revenue_analysis(tenant_id, period)
        elif analysis_type == 'competitive_analysis':
            return await self.competitive_analysis(tenant_id, period)
        
    async def customer_segmentation_analysis(self, tenant_id: str, period: str) -> AIResult:
        """é¡§å®¢ã‚»ã‚°ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³åˆ†æ"""
        # é¡§å®¢ãƒ‡ãƒ¼ã‚¿åé›†
        customers = await self.get_customer_data_for_segmentation(tenant_id, period)
        
        # ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°å®Ÿè¡Œ
        from sklearn.cluster import KMeans
        import pandas as pd
        
        df = pd.DataFrame(customers)
        features = ['total_spend', 'stay_frequency', 'avg_stay_duration', 'service_usage']
        
        kmeans = KMeans(n_clusters=4, random_state=42)
        df['segment'] = kmeans.fit_predict(df[features])
        
        # ã‚»ã‚°ãƒ¡ãƒ³ãƒˆåˆ†æ
        segment_profiles = df.groupby('segment').agg({
            'total_spend': ['mean', 'median'],
            'stay_frequency': 'mean',
            'avg_stay_duration': 'mean',
            'service_usage': 'mean'
        }).round(2)
        
        # AI ã«ã‚ˆã‚‹ã‚»ã‚°ãƒ¡ãƒ³ãƒˆè§£é‡ˆ
        interpretation_prompt = f"""
        ãƒ›ãƒ†ãƒ«é¡§å®¢ã‚»ã‚°ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³çµæœã‚’åˆ†æã—ã€å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®ç‰¹å¾´ã¨
        ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°æˆ¦ç•¥ã‚’ææ¡ˆã—ã¦ãã ã•ã„ï¼š
        
        ã‚»ã‚°ãƒ¡ãƒ³ãƒˆåˆ†æçµæœ:
        {segment_profiles.to_string()}
        
        å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã«å¯¾ã—ã¦ä»¥ä¸‹ã‚’æä¾›ã—ã¦ãã ã•ã„ï¼š
        1. ã‚»ã‚°ãƒ¡ãƒ³ãƒˆåï¼ˆç‰¹å¾´çš„ãªåå‰ï¼‰
        2. ä¸»è¦ç‰¹å¾´
        3. ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°æˆ¦ç•¥
        4. æ¨å¥¨ã‚µãƒ¼ãƒ“ã‚¹
        """
        
        interpretation = await openai.ChatCompletion.acreate(
            model="gpt-4o",
            messages=[{"role": "user", "content": interpretation_prompt}],
            temperature=0.3,
            max_tokens=1200
        )
        
        return AIResult(
            output=interpretation.choices[0].message.content,
            confidence=0.88,
            additional_data={
                "segment_data": segment_profiles.to_dict(),
                "cluster_centers": kmeans.cluster_centers_.tolist(),
                "segment_counts": df['segment'].value_counts().to_dict()
            }
        )
```

---

## ğŸ“± **ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ UIå®Ÿè£…**

### **ğŸ›ï¸ ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆç®¡ç†ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰**

#### **Vue 3 + Composition APIå®Ÿè£…**
```vue
<!-- components/CreditDashboard.vue -->
<template>
  <div class="credit-dashboard">
    <!-- ãƒ¡ã‚¤ãƒ³ãƒ˜ãƒƒãƒ€ãƒ¼: æ®‹é«˜è¡¨ç¤º -->
    <div class="dashboard-header">
      <div class="balance-card">
        <div class="balance-main">
          <h1 class="balance-number">{{ formatNumber(balance.currentBalance) }}</h1>
          <span class="balance-unit">ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆæ®‹ã‚Š</span>
        </div>
        
        <div class="balance-progress">
          <div class="progress-circle-container">
            <svg class="progress-circle" viewBox="0 0 120 120">
              <circle cx="60" cy="60" r="54" fill="none" stroke="#f3f4f6" stroke-width="8"/>
              <circle 
                cx="60" cy="60" r="54" fill="none" 
                stroke="#3b82f6" stroke-width="8"
                :stroke-dasharray="circumference"
                :stroke-dashoffset="progressOffset"
                stroke-linecap="round"
                transform="rotate(-90 60 60)"
              />
            </svg>
            <div class="progress-text">
              <span class="progress-percentage">{{ Math.round(usagePercentage) }}%</span>
              <span class="progress-label">ä»Šæœˆä½¿ç”¨</span>
            </div>
          </div>
        </div>
        
        <div class="balance-actions">
          <button @click="showPurchaseModal = true" class="btn-primary">
            <Icon name="credit-card" />
            ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆè³¼å…¥
          </button>
          <button @click="toggleAutoPurchase" class="btn-secondary">
            <Icon :name="autoPurchase.enabled ? 'toggle-on' : 'toggle-off'" />
            è‡ªå‹•è³¼å…¥: {{ autoPurchase.enabled ? 'ON' : 'OFF' }}
          </button>
        </div>
      </div>
      
      <!-- ãƒ—ãƒ©ãƒ³æƒ…å ± -->
      <div class="plan-card">
        <h3>{{ planDisplayName }}</h3>
        <div class="plan-details">
          <div class="plan-item">
            <span class="plan-label">æœˆé–“ç„¡æ–™ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆ</span>
            <span class="plan-value">{{ balance.monthlyFreeCredits }}</span>
          </div>
          <div class="plan-item">
            <span class="plan-label">æ®‹ã‚Šäºˆæƒ³æ—¥æ•°</span>
            <span class="plan-value">{{ balance.estimatedDaysLeft }}æ—¥</span>
          </div>
        </div>
        <button @click="showPlanModal = true" class="btn-outline">
          ãƒ—ãƒ©ãƒ³å¤‰æ›´
        </button>
      </div>
    </div>
    
    <!-- ä½¿ç”¨çŠ¶æ³ãƒãƒ£ãƒ¼ãƒˆ -->
    <div class="charts-section">
      <div class="chart-container">
        <h3>æ©Ÿèƒ½åˆ¥ä½¿ç”¨é‡</h3>
        <canvas ref="functionChart" class="chart-canvas"></canvas>
        <div class="chart-legend">
          <div v-for="item in functionUsage" :key="item.functionType" class="legend-item">
            <div class="legend-color" :style="{ backgroundColor: getFunctionColor(item.functionType) }"></div>
            <span class="legend-label">{{ getFunctionDisplayName(item.functionType) }}</span>
            <span class="legend-value">{{ item.creditsUsed }}ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆ</span>
          </div>
        </div>
      </div>
      
      <div class="chart-container">
        <h3>æ—¥åˆ¥ä½¿ç”¨æ¨ç§»ï¼ˆéå»30æ—¥ï¼‰</h3>
        <canvas ref="dailyChart" class="chart-canvas"></canvas>
      </div>
    </div>
    
    <!-- æœ€è¿‘ã®ä½¿ç”¨å±¥æ­´ -->
    <div class="recent-usage-section">
      <div class="section-header">
        <h3>æœ€è¿‘ã®ä½¿ç”¨å±¥æ­´</h3>
        <button @click="showFullHistory = true" class="btn-text">
          å…¨å±¥æ­´ã‚’è¦‹ã‚‹
        </button>
      </div>
      
      <div class="usage-list">
        <div v-for="transaction in recentTransactions" :key="transaction.id" class="usage-item">
          <div class="usage-icon">
            <Icon :name="getFunctionIcon(transaction.ai_function_type)" />
          </div>
          <div class="usage-content">
            <div class="usage-function">
              {{ getFunctionDisplayName(transaction.ai_function_type) }}
            </div>
            <div class="usage-details">
              <span class="usage-time">{{ formatDateTime(transaction.created_at) }}</span>
              <span class="usage-user" v-if="transaction.user_name">
                by {{ transaction.user_name }}
              </span>
            </div>
            <div class="usage-params" v-if="transaction.ai_function_params">
              {{ formatFunctionParams(transaction.ai_function_params) }}
            </div>
          </div>
          <div class="usage-cost">
            <span class="cost-amount">-{{ Math.abs(transaction.credits_amount) }}</span>
            <span class="cost-unit">ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆ</span>
          </div>
        </div>
        
        <div v-if="recentTransactions.length === 0" class="empty-state">
          <Icon name="chart-line" size="48" />
          <p>ã¾ã ä½¿ç”¨å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“</p>
          <p class="empty-subtitle">AIæ©Ÿèƒ½ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ã“ã“ã«å±¥æ­´ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</p>
        </div>
      </div>
    </div>
  </div>
  
  <!-- ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆè³¼å…¥ãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <CreditPurchaseModal 
    v-if="showPurchaseModal"
    :current-plan="balance.planType"
    @close="showPurchaseModal = false"
    @purchase-complete="handlePurchaseComplete"
  />
  
  <!-- ãƒ—ãƒ©ãƒ³å¤‰æ›´ãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <PlanChangeModal
    v-if="showPlanModal"
    :current-plan="balance.planType"
    @close="showPlanModal = false"
    @plan-changed="handlePlanChanged"
  />
  
  <!-- ä½¿ç”¨å±¥æ­´è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <UsageHistoryModal
    v-if="showFullHistory"
    @close="showFullHistory = false"
  />
</template>

<script setup lang="ts">
import { ref, computed, onMounted, watch } from 'vue'
import { useCreditStore } from '@/stores/credit'
import { useNotificationStore } from '@/stores/notification'
import Chart from 'chart.js/auto'
import Icon from '@/components/ui/Icon.vue'

// ã‚¹ãƒˆã‚¢
const creditStore = useCreditStore()
const notificationStore = useNotificationStore()

// ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹
const showPurchaseModal = ref(false)
const showPlanModal = ref(false)
const showFullHistory = ref(false)
const functionChart = ref<HTMLCanvasElement>()
const dailyChart = ref<HTMLCanvasElement>()

// è¨ˆç®—ã•ã‚ŒãŸãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
const balance = computed(() => creditStore.balance)
const autoPurchase = computed(() => creditStore.autoPurchaseSettings)
const recentTransactions = computed(() => creditStore.recentTransactions)
const functionUsage = computed(() => creditStore.functionUsage)

const planDisplayName = computed(() => {
  const plans = {
    'ESSENTIAL': 'Essential ãƒ—ãƒ©ãƒ³',
    'PROFESSIONAL': 'Professional ãƒ—ãƒ©ãƒ³',
    'ENTERPRISE': 'Enterprise ãƒ—ãƒ©ãƒ³'
  }
  return plans[balance.value.planType] || balance.value.planType
})

const usagePercentage = computed(() => {
  const used = balance.value.usedThisMonth
  const total = balance.value.monthlyFreeCredits
  return Math.min((used / total) * 100, 100)
})

// ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ã‚µãƒ¼ã‚¯ãƒ«
const circumference = 2 * Math.PI * 54
const progressOffset = computed(() => {
  return circumference - (usagePercentage.value / 100) * circumference
})

// ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«
onMounted(async () => {
  await loadDashboardData()
  initializeCharts()
  
  // 5åˆ†ã”ã¨ã«æ®‹é«˜æ›´æ–°
  setInterval(async () => {
    await creditStore.fetchBalance()
  }, 5 * 60 * 1000)
})

// ãƒ¡ã‚½ãƒƒãƒ‰
const loadDashboardData = async () => {
  try {
    await Promise.all([
      creditStore.fetchBalance(),
      creditStore.fetchRecentTransactions(),
      creditStore.fetchUsageAnalytics()
    ])
  } catch (error) {
    notificationStore.addError('ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ')
  }
}

const initializeCharts = () => {
  if (functionChart.value) {
    new Chart(functionChart.value, {
      type: 'doughnut',
      data: {
        labels: functionUsage.value.map(f => getFunctionDisplayName(f.functionType)),
        datasets: [{
          data: functionUsage.value.map(f => f.creditsUsed),
          backgroundColor: functionUsage.value.map(f => getFunctionColor(f.functionType)),
          borderWidth: 0
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              label: (context) => {
                const percentage = ((context.parsed / getTotalUsage()) * 100).toFixed(1)
                return `${context.label}: ${context.parsed}ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆ (${percentage}%)`
              }
            }
          }
        }
      }
    })
  }
  
  if (dailyChart.value) {
    new Chart(dailyChart.value, {
      type: 'line',
      data: {
        labels: creditStore.dailyUsage.map(d => formatDate(d.date)),
        datasets: [{
          label: 'ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆä½¿ç”¨é‡',
          data: creditStore.dailyUsage.map(d => d.credits),
          borderColor: '#3b82f6',
          backgroundColor: 'rgba(59, 130, 246, 0.1)',
          borderWidth: 2,
          fill: true,
          tension: 0.4
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false }
        },
        scales: {
          y: { 
            beginAtZero: true,
            ticks: {
              callback: (value) => `${value}cr`
            }
          }
        }
      }
    })
  }
}

const toggleAutoPurchase = async () => {
  try {
    await creditStore.updateAutoPurchaseSettings({
      enabled: !autoPurchase.value.enabled,
      threshold: autoPurchase.value.threshold,
      purchaseAmount: autoPurchase.value.purchaseAmount
    })
    
    notificationStore.addSuccess(
      autoPurchase.value.enabled ? 'è‡ªå‹•è³¼å…¥ã‚’æœ‰åŠ¹ã«ã—ã¾ã—ãŸ' : 'è‡ªå‹•è³¼å…¥ã‚’ç„¡åŠ¹ã«ã—ã¾ã—ãŸ'
    )
  } catch (error) {
    notificationStore.addError('è‡ªå‹•è³¼å…¥è¨­å®šã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ')
  }
}

const handlePurchaseComplete = async (result: any) => {
  showPurchaseModal.value = false
  await loadDashboardData()
  
  notificationStore.addSuccess(
    `${result.creditsAdded}ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆã‚’è¿½åŠ ã—ã¾ã—ãŸ`
  )
}

const handlePlanChanged = async (newPlan: string) => {
  showPlanModal.value = false
  await loadDashboardData()
  
  notificationStore.addSuccess(`${newPlan}ãƒ—ãƒ©ãƒ³ã«å¤‰æ›´ã—ã¾ã—ãŸ`)
}

// ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
const formatNumber = (num: number): string => {
  return new Intl.NumberFormat('ja-JP').format(num)
}

const formatDateTime = (dateString: string): string => {
  return new Intl.DateTimeFormat('ja-JP', {
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  }).format(new Date(dateString))
}

const getFunctionDisplayName = (functionType: string): string => {
  const names = {
    'CHATBOT': 'AIãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆ',
    'RECOMMENDATION': 'ãƒ¬ã‚³ãƒ¡ãƒ³ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³',
    'PREDICTION': 'äºˆæ¸¬åˆ†æ',
    'ANALYSIS': 'é«˜åº¦åˆ†æ',
    'CUSTOM': 'ã‚«ã‚¹ã‚¿ãƒ æ©Ÿèƒ½'
  }
  return names[functionType] || functionType
}

const getFunctionColor = (functionType: string): string => {
  const colors = {
    'CHATBOT': '#3b82f6',
    'RECOMMENDATION': '#10b981',
    'PREDICTION': '#f59e0b',
    'ANALYSIS': '#ef4444',
    'CUSTOM': '#8b5cf6'
  }
  return colors[functionType] || '#6b7280'
}

const getFunctionIcon = (functionType: string): string => {
  const icons = {
    'CHATBOT': 'chat-bubble',
    'RECOMMENDATION': 'star',
    'PREDICTION': 'chart-trending-up',
    'ANALYSIS': 'chart-bar',
    'CUSTOM': 'cog'
  }
  return icons[functionType] || 'question-mark'
}
</script>

<style scoped>
.credit-dashboard {
  @apply max-w-7xl mx-auto p-6 space-y-6;
}

.dashboard-header {
  @apply grid grid-cols-1 lg:grid-cols-2 gap-6;
}

.balance-card {
  @apply bg-white rounded-xl shadow-lg p-6 border border-gray-200;
}

.balance-main {
  @apply text-center mb-6;
}

.balance-number {
  @apply text-4xl font-bold text-gray-900 mb-2;
}

.balance-unit {
  @apply text-lg text-gray-600;
}

.progress-circle-container {
  @apply relative w-32 h-32 mx-auto mb-6;
}

.progress-circle {
  @apply w-full h-full;
}

.progress-text {
  @apply absolute inset-0 flex flex-col items-center justify-center;
}

.progress-percentage {
  @apply text-xl font-semibold text-gray-900;
}

.progress-label {
  @apply text-sm text-gray-600;
}

.balance-actions {
  @apply flex gap-3 justify-center;
}

.btn-primary {
  @apply bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors flex items-center gap-2;
}

.btn-secondary {
  @apply bg-gray-100 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-200 transition-colors flex items-center gap-2;
}

.plan-card {
  @apply bg-white rounded-xl shadow-lg p-6 border border-gray-200;
}

.plan-details {
  @apply space-y-3 my-4;
}

.plan-item {
  @apply flex justify-between items-center;
}

.plan-label {
  @apply text-gray-600;
}

.plan-value {
  @apply font-semibold text-gray-900;
}

.charts-section {
  @apply grid grid-cols-1 lg:grid-cols-2 gap-6;
}

.chart-container {
  @apply bg-white rounded-xl shadow-lg p-6 border border-gray-200;
}

.chart-canvas {
  @apply h-64;
}

.chart-legend {
  @apply mt-4 space-y-2;
}

.legend-item {
  @apply flex items-center gap-3;
}

.legend-color {
  @apply w-3 h-3 rounded-full;
}

.recent-usage-section {
  @apply bg-white rounded-xl shadow-lg border border-gray-200;
}

.section-header {
  @apply flex justify-between items-center p-6 border-b border-gray-200;
}

.usage-list {
  @apply divide-y divide-gray-200;
}

.usage-item {
  @apply flex items-center gap-4 p-4 hover:bg-gray-50 transition-colors;
}

.usage-icon {
  @apply w-10 h-10 bg-blue-100 rounded-lg flex items-center justify-center text-blue-600;
}

.usage-content {
  @apply flex-1 min-w-0;
}

.usage-function {
  @apply font-medium text-gray-900;
}

.usage-details {
  @apply text-sm text-gray-600 space-x-2;
}

.usage-cost {
  @apply text-right;
}

.cost-amount {
  @apply text-lg font-semibold text-red-600;
}

.cost-unit {
  @apply text-sm text-gray-600;
}

.empty-state {
  @apply text-center py-12 text-gray-500;
}

.empty-subtitle {
  @apply text-sm;
}
</style>
```

---

## ğŸ” **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»ç›£æŸ»å®Ÿè£…**

### **ğŸ›¡ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢**

#### **FastAPI ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š**
```python
# app/middleware/security.py
from fastapi import Request, HTTPException, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from starlette.middleware.base import BaseHTTPMiddleware
import time
import redis
from app.core.security import verify_jwt_token, check_rate_limit

class SecurityMiddleware(BaseHTTPMiddleware):
    def __init__(self, app, redis_client):
        super().__init__(app)
        self.redis = redis_client
        self.rate_limiter = RateLimiter(redis_client)
        
    async def dispatch(self, request: Request, call_next):
        # ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒã‚§ãƒƒã‚¯
        client_ip = self.get_client_ip(request)
        
        if await self.rate_limiter.is_rate_limited(client_ip, request.url.path):
            raise HTTPException(
                status_code=429,
                detail="ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã«é”ã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãæ™‚é–“ã‚’ãŠã„ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚"
            )
        
        # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼è¿½åŠ 
        response = await call_next(request)
        
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
        
        return response

class RateLimiter:
    def __init__(self, redis_client):
        self.redis = redis_client
        
    async def is_rate_limited(self, identifier: str, endpoint: str) -> bool:
        """ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒã‚§ãƒƒã‚¯"""
        # ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆåˆ¥åˆ¶é™è¨­å®š
        limits = {
            '/api/v1/ai/execute': {'requests': 100, 'window': 3600},  # 1æ™‚é–“100å›
            '/api/v1/credits/purchase': {'requests': 10, 'window': 3600},  # 1æ™‚é–“10å›
            '/api/v1/credits/balance': {'requests': 1000, 'window': 3600},  # 1æ™‚é–“1000å›
        }
        
        limit_config = limits.get(endpoint, {'requests': 200, 'window': 3600})
        
        key = f"rate_limit:{identifier}:{endpoint}"
        current_time = int(time.time())
        window_start = current_time - limit_config['window']
        
        # ã‚¹ãƒ©ã‚¤ãƒ‡ã‚£ãƒ³ã‚°ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ­ã‚°
        pipe = self.redis.pipeline()
        pipe.zremrangebyscore(key, 0, window_start)
        pipe.zadd(key, {str(current_time): current_time})
        pipe.zcard(key)
        pipe.expire(key, limit_config['window'])
        
        results = pipe.execute()
        current_requests = results[2]
        
        return current_requests > limit_config['requests']

# èªè¨¼ãƒ»èªå¯
security = HTTPBearer()

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """JWTãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼ãƒ»ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±å–å¾—"""
    try:
        payload = verify_jwt_token(credentials.credentials)
        return payload
    except Exception as e:
        raise HTTPException(
            status_code=401,
            detail="èªè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸ",
            headers={"WWW-Authenticate": "Bearer"}
        )

async def require_credit_access(
    user: dict = Depends(get_current_user),
    request: Request = None
):
    """ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆæ©Ÿèƒ½ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãƒã‚§ãƒƒã‚¯"""
    if not user.get('permissions') or 'credit_management' not in user['permissions']:
        raise HTTPException(
            status_code=403,
            detail="ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆç®¡ç†æ©Ÿèƒ½ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“"
        )
    
    # ç•°å¸¸ä½¿ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œçŸ¥
    usage_score = await detect_anomalous_usage(user['user_id'], request)
    if usage_score > 80:  # 80ç‚¹ä»¥ä¸Šã§è­¦å‘Š
        await log_security_event({
            'type': 'ANOMALOUS_USAGE',
            'user_id': user['user_id'],
            'tenant_id': user['tenant_id'],
            'anomaly_score': usage_score,
            'endpoint': str(request.url),
            'ip_address': request.client.host
        })
        
        if usage_score > 95:  # 95ç‚¹ä»¥ä¸Šã§ä¸€æ™‚åœæ­¢
            raise HTTPException(
                status_code=403,
                detail="ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®ç†ç”±ã«ã‚ˆã‚Šä¸€æ™‚çš„ã«åˆ©ç”¨ã‚’åˆ¶é™ã—ã¦ã„ã¾ã™"
            )
    
    return user

async def detect_anomalous_usage(user_id: str, request: Request) -> float:
    """ç•°å¸¸ä½¿ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œçŸ¥"""
    # æœ€è¿‘1æ™‚é–“ã®ä½¿ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ
    recent_usage = await get_recent_usage_pattern(user_id)
    
    # ç•°å¸¸ã‚¹ã‚³ã‚¢è¨ˆç®—
    frequency_score = calculate_frequency_anomaly(recent_usage)
    volume_score = calculate_volume_anomaly(recent_usage)
    time_score = calculate_time_anomaly(recent_usage)
    
    return max(frequency_score, volume_score, time_score)
```

### **ğŸ“‹ ç›£æŸ»ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ **

#### **åŒ…æ‹¬çš„ç›£æŸ»ãƒ­ã‚°**
```python
# app/services/audit_service.py
from sqlalchemy.orm import Session
from app.models.audit import AuditLog
import json
from datetime import datetime

class AuditService:
    def __init__(self, db: Session):
        self.db = db
    
    async def log_credit_transaction(
        self,
        user_id: str,
        tenant_id: str,
        transaction_id: str,
        action: str,
        details: dict,
        request_info: dict = None
    ):
        """ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆå–å¼•ç›£æŸ»ãƒ­ã‚°"""
        audit_log = AuditLog(
            user_id=user_id,
            tenant_id=tenant_id,
            action=action,
            resource_type='ai_credit_transaction',
            resource_id=transaction_id,
            details=json.dumps(details),
            ip_address=request_info.get('ip_address') if request_info else None,
            user_agent=request_info.get('user_agent') if request_info else None,
            timestamp=datetime.utcnow()
        )
        
        self.db.add(audit_log)
        self.db.commit()
    
    async def log_ai_function_execution(
        self,
        user_id: str,
        tenant_id: str,
        function_type: str,
        execution_details: dict,
        credits_used: int,
        request_info: dict = None
    ):
        """AIæ©Ÿèƒ½å®Ÿè¡Œç›£æŸ»ãƒ­ã‚°"""
        audit_log = AuditLog(
            user_id=user_id,
            tenant_id=tenant_id,
            action='AI_FUNCTION_EXECUTION',
            resource_type='ai_function',
            resource_id=execution_details.get('execution_id'),
            details=json.dumps({
                'function_type': function_type,
                'credits_used': credits_used,
                'execution_time': execution_details.get('execution_time'),
                'parameters': execution_details.get('parameters'),
                'result_summary': execution_details.get('result_summary')
            }),
            ip_address=request_info.get('ip_address'),
            user_agent=request_info.get('user_agent'),
            timestamp=datetime.utcnow()
        )
        
        self.db.add(audit_log)
        self.db.commit()
    
    async def log_security_event(
        self,
        user_id: str,
        tenant_id: str,
        event_type: str,
        severity: str,
        details: dict,
        request_info: dict = None
    ):
        """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆç›£æŸ»ãƒ­ã‚°"""
        audit_log = AuditLog(
            user_id=user_id,
            tenant_id=tenant_id,
            action='SECURITY_EVENT',
            resource_type='security',
            resource_id=event_type,
            details=json.dumps({
                'event_type': event_type,
                'severity': severity,
                'anomaly_score': details.get('anomaly_score'),
                'detection_rules': details.get('detection_rules'),
                'risk_factors': details.get('risk_factors')
            }),
            ip_address=request_info.get('ip_address'),
            user_agent=request_info.get('user_agent'),
            timestamp=datetime.utcnow()
        )
        
        self.db.add(audit_log)
        self.db.commit()
        
        # é«˜é‡è¦åº¦ã‚¤ãƒ™ãƒ³ãƒˆã¯å³åº§ã«ã‚¢ãƒ©ãƒ¼ãƒˆ
        if severity in ['HIGH', 'CRITICAL']:
            await self.send_security_alert(audit_log)
    
    async def generate_compliance_report(
        self,
        tenant_id: str,
        start_date: datetime,
        end_date: datetime
    ) -> dict:
        """ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ"""
        # ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹ãƒ­ã‚°é›†è¨ˆ
        access_logs = self.db.query(AuditLog).filter(
            AuditLog.tenant_id == tenant_id,
            AuditLog.timestamp.between(start_date, end_date),
            AuditLog.action.in_(['READ', 'CREATE', 'UPDATE', 'DELETE'])
        ).all()
        
        # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆé›†è¨ˆ
        security_events = self.db.query(AuditLog).filter(
            AuditLog.tenant_id == tenant_id,
            AuditLog.timestamp.between(start_date, end_date),
            AuditLog.action == 'SECURITY_EVENT'
        ).all()
        
        # AIæ©Ÿèƒ½ä½¿ç”¨ãƒ­ã‚°é›†è¨ˆ
        ai_usage_logs = self.db.query(AuditLog).filter(
            AuditLog.tenant_id == tenant_id,
            AuditLog.timestamp.between(start_date, end_date),
            AuditLog.action == 'AI_FUNCTION_EXECUTION'
        ).all()
        
        return {
            'period': {
                'start_date': start_date.isoformat(),
                'end_date': end_date.isoformat()
            },
            'summary': {
                'total_data_accesses': len(access_logs),
                'security_incidents': len(security_events),
                'ai_function_executions': len(ai_usage_logs)
            },
            'data_access_patterns': self.analyze_access_patterns(access_logs),
            'security_assessment': self.assess_security_posture(security_events),
            'ai_usage_compliance': self.check_ai_usage_compliance(ai_usage_logs),
            'recommendations': self.generate_compliance_recommendations(
                access_logs, security_events, ai_usage_logs
            )
        }
```

---

## ğŸ“ˆ **é‹ç”¨ç›£è¦–ãƒ»ã‚¢ãƒ©ãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ **

### **âš¡ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–**

#### **ç›£è¦–ã‚µãƒ¼ãƒ“ã‚¹**
```python
# app/services/monitoring_service.py
import asyncio
from datetime import datetime, timedelta
from app.services.notification_service import NotificationService
from app.models.ai_credit import AICreditAccount, AICreditTransaction

class CreditMonitoringService:
    def __init__(self, db, redis_client):
        self.db = db
        self.redis = redis_client
        self.notification_service = NotificationService()
        
    async def start_monitoring(self):
        """ç›£è¦–ã‚µãƒ¼ãƒ“ã‚¹é–‹å§‹"""
        # æ®‹é«˜ç›£è¦–ï¼ˆ5åˆ†é–“éš”ï¼‰
        asyncio.create_task(self.monitor_low_balance())
        
        # ä½¿ç”¨é‡æ€¥å¢—ç›£è¦–ï¼ˆ1åˆ†é–“éš”ï¼‰
        asyncio.create_task(self.monitor_usage_spikes())
        
        # æ±ºæ¸ˆå¤±æ•—ç›£è¦–ï¼ˆå³æ™‚ï¼‰
        asyncio.create_task(self.monitor_payment_failures())
        
        # ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ç›£è¦–ï¼ˆ30ç§’é–“éš”ï¼‰
        asyncio.create_task(self.monitor_system_health())
    
    async def monitor_low_balance(self):
        """æ®‹é«˜ç›£è¦–"""
        while True:
            try:
                # æ®‹é«˜50ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆæœªæº€ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆæ¤œç´¢
                low_balance_accounts = self.db.query(AICreditAccount).filter(
                    AICreditAccount.current_balance < 50,
                    AICreditAccount.deleted_at.is_(None)
                ).all()
                
                for account in low_balance_accounts:
                    alert_key = f"low_balance_alert:{account.id}"
                    
                    # 24æ™‚é–“ä»¥å†…ã«åŒã˜ã‚¢ãƒ©ãƒ¼ãƒˆã‚’é€ä¿¡ã—ã¦ã„ãªã„å ´åˆã®ã¿
                    if not await self.redis.get(alert_key):
                        severity = 'CRITICAL' if account.current_balance < 10 else 'WARNING'
                        
                        await self.notification_service.send_alert({
                            'type': 'LOW_BALANCE',
                            'severity': severity,
                            'tenant_id': account.tenant_id,
                            'title': 'ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆæ®‹é«˜è­¦å‘Š',
                            'message': f'ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆæ®‹é«˜ãŒå°‘ãªããªã£ã¦ã„ã¾ã™: {account.current_balance}ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆ',
                            'data': {
                                'current_balance': account.current_balance,
                                'plan_type': account.plan_type,
                                'estimated_days_left': await self.calculate_days_left(account),
                                'auto_purchase_enabled': account.auto_purchase_enabled
                            },
                            'actions': [
                                {
                                    'label': 'ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆè³¼å…¥',
                                    'url': f'/credits/purchase?account_id={account.id}'
                                },
                                {
                                    'label': 'è‡ªå‹•è³¼å…¥è¨­å®š',
                                    'url': f'/credits/settings?account_id={account.id}'
                                }
                            ]
                        })
                        
                        # 24æ™‚é–“å¾Œã¾ã§åŒã˜ã‚¢ãƒ©ãƒ¼ãƒˆã‚’é€ä¿¡ã—ãªã„
                        await self.redis.setex(alert_key, 24 * 60 * 60, '1')
                
                await asyncio.sleep(5 * 60)  # 5åˆ†å¾…æ©Ÿ
                
            except Exception as e:
                print(f"æ®‹é«˜ç›£è¦–ã‚¨ãƒ©ãƒ¼: {e}")
                await asyncio.sleep(60)  # ã‚¨ãƒ©ãƒ¼æ™‚ã¯1åˆ†å¾…æ©Ÿ
    
    async def monitor_usage_spikes(self):
        """ä½¿ç”¨é‡æ€¥å¢—ç›£è¦–"""
        while True:
            try:
                current_hour = datetime.utcnow().replace(minute=0, second=0, microsecond=0)
                hour_ago = current_hour - timedelta(hours=1)
                
                # éå»1æ™‚é–“ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆåˆ¥ä½¿ç”¨é‡
                hourly_usage = self.db.query(
                    AICreditTransaction.account_id,
                    func.sum(func.abs(AICreditTransaction.credits_amount)).label('credits_used')
                ).filter(
                    AICreditTransaction.transaction_type == 'USAGE',
                    AICreditTransaction.created_at >= hour_ago
                ).group_by(AICreditTransaction.account_id).all()
                
                for usage in hourly_usage:
                    account = self.db.query(AICreditAccount).filter(
                        AICreditAccount.id == usage.account_id
                    ).first()
                    
                    if not account:
                        continue
                    
                    # éå»30æ—¥ã®æ™‚é–“åˆ¥å¹³å‡ä½¿ç”¨é‡
                    avg_hourly_usage = await self.get_average_hourly_usage(
                        usage.account_id, 30
                    )
                    
                    # å¹³å‡ã®3å€ä»¥ä¸Šã®ä½¿ç”¨é‡ã‚’ã‚¹ãƒ‘ã‚¤ã‚¯ã¨ã—ã¦åˆ¤å®š
                    if usage.credits_used > avg_hourly_usage * 3:
                        await self.notification_service.send_alert({
                            'type': 'USAGE_SPIKE',
                            'severity': 'WARNING',
                            'tenant_id': account.tenant_id,
                            'title': 'ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆä½¿ç”¨é‡æ€¥å¢—',
                            'message': f'æ™‚é–“ã‚ãŸã‚Šã®ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆä½¿ç”¨é‡ãŒæ€¥å¢—ã—ã¦ã„ã¾ã™: {usage.credits_used}ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆ',
                            'data': {
                                'current_hour_usage': usage.credits_used,
                                'average_hourly_usage': avg_hourly_usage,
                                'spike_ratio': usage.credits_used / avg_hourly_usage,
                                'account_balance': account.current_balance
                            }
                        })
                
                await asyncio.sleep(60)  # 1åˆ†å¾…æ©Ÿ
                
            except Exception as e:
                print(f"ä½¿ç”¨é‡ç›£è¦–ã‚¨ãƒ©ãƒ¼: {e}")
                await asyncio.sleep(60)
    
    async def monitor_system_health(self):
        """ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ç›£è¦–"""
        while True:
            try:
                health_checks = []
                
                # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šãƒã‚§ãƒƒã‚¯
                health_checks.append(await self.check_database_health())
                
                # Redisæ¥ç¶šãƒã‚§ãƒƒã‚¯
                health_checks.append(await self.check_redis_health())
                
                # OpenAI API ãƒã‚§ãƒƒã‚¯
                health_checks.append(await self.check_openai_health())
                
                # Stripe API ãƒã‚§ãƒƒã‚¯
                health_checks.append(await self.check_stripe_health())
                
                failed_checks = [check for check in health_checks if not check['healthy']]
                
                if failed_checks:
                    await self.notification_service.send_system_alert({
                        'type': 'SYSTEM_HEALTH',
                        'severity': 'CRITICAL' if len(failed_checks) > 1 else 'WARNING',
                        'title': 'ã‚·ã‚¹ãƒ†ãƒ ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ç•°å¸¸',
                        'message': f'{len(failed_checks)}å€‹ã®ã‚µãƒ¼ãƒ“ã‚¹ã§å•é¡ŒãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ',
                        'data': {
                            'failed_services': [check['service'] for check in failed_checks],
                            'total_checks': len(health_checks),
                            'failed_checks': len(failed_checks),
                            'details': failed_checks
                        }
                    })
                
                await asyncio.sleep(30)  # 30ç§’å¾…æ©Ÿ
                
            except Exception as e:
                print(f"ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ã‚¨ãƒ©ãƒ¼: {e}")
                await asyncio.sleep(60)
```

---

## ğŸ“‹ **å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ**

### **âœ… Phase 1: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ»åŸºç›¤ï¼ˆWeek 1-2ï¼‰**
```
ğŸ”´ æœ€å„ªå…ˆå®Ÿè£…:
â”œâ”€â”€ [ ] ai_credit_accounts ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆãƒ»ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
â”œâ”€â”€ [ ] ai_credit_transactions ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆãƒ»ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
â”œâ”€â”€ [ ] ai_credit_packages ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆãƒ»ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
â”œâ”€â”€ [ ] monthly_credit_resets ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆãƒ»ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
â”œâ”€â”€ [ ] æ—¢å­˜ãƒ†ãƒ¼ãƒ–ãƒ«æ‹¡å¼µï¼ˆusers, tenantsï¼‰
â”œâ”€â”€ [ ] SQLAlchemy ãƒ¢ãƒ‡ãƒ«ä½œæˆãƒ»è¨­å®š
â”œâ”€â”€ [ ] åŸºæœ¬CRUDæ“ä½œ APIå®Ÿè£…
â””â”€â”€ [ ] ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šãƒ»è¨­å®šç¢ºèª

ğŸŸ¡ é‡è¦å®Ÿè£…:
â”œâ”€â”€ [ ] StripeåŸºæœ¬çµ±åˆãƒ»APIã‚­ãƒ¼è¨­å®š
â”œâ”€â”€ [ ] OpenAI APIçµ±åˆãƒ»APIã‚­ãƒ¼è¨­å®š
â”œâ”€â”€ [ ] Redisæ¥ç¶šãƒ»ã‚­ãƒ£ãƒƒã‚·ãƒ¥è¨­å®š
â””â”€â”€ [ ] åŸºæœ¬èªè¨¼ãƒ»ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š
```

### **âœ… Phase 2: ã‚³ã‚¢æ©Ÿèƒ½å®Ÿè£…ï¼ˆWeek 3-5ï¼‰**
```
ğŸ”´ æœ€å„ªå…ˆå®Ÿè£…:
â”œâ”€â”€ [ ] ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆæ®‹é«˜ç¢ºèªAPIå®Œæˆ
â”œâ”€â”€ [ ] AIæ©Ÿèƒ½å®Ÿè¡ŒAPIï¼ˆãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆåŸºæœ¬ï¼‰
â”œâ”€â”€ [ ] ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆæ¶ˆè²»å‡¦ç†ãƒ»å±¥æ­´è¨˜éŒ²
â”œâ”€â”€ [ ] Stripeæ±ºæ¸ˆAPIãƒ»ã‚¦ã‚§ãƒ–ãƒ•ãƒƒã‚¯å‡¦ç†
â”œâ”€â”€ [ ] è‡ªå‹•è³¼å…¥æ©Ÿèƒ½å®Ÿè£…
â”œâ”€â”€ [ ] æœˆæ¬¡ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½ãƒ»cronè¨­å®š
â””â”€â”€ [ ] åŸºæœ¬ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰UIå®Ÿè£…

ğŸŸ¡ é‡è¦å®Ÿè£…:
â”œâ”€â”€ [ ] ãƒ¬ã‚³ãƒ¡ãƒ³ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½å®Ÿè£…
â”œâ”€â”€ [ ] äºˆæ¸¬åˆ†ææ©Ÿèƒ½å®Ÿè£…
â”œâ”€â”€ [ ] ä½¿ç”¨çµ±è¨ˆãƒ»åˆ†æAPI
â””â”€â”€ [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ»ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ 
```

### **âœ… Phase 3: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»é‹ç”¨ï¼ˆWeek 6-9ï¼‰**
```
ğŸ”´ æœ€å„ªå…ˆå®Ÿè£…:
â”œâ”€â”€ [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢å®Ÿè£…
â”œâ”€â”€ [ ] ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒ»ç•°å¸¸æ¤œçŸ¥ã‚·ã‚¹ãƒ†ãƒ 
â”œâ”€â”€ [ ] ç›£æŸ»ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ å®Œæˆ
â”œâ”€â”€ [ ] ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–ãƒ»ã‚¢ãƒ©ãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ 
â”œâ”€â”€ [ ] æ£®è—¤æ°ãƒ‘ã‚¤ãƒ­ãƒƒãƒˆç’°å¢ƒæ§‹ç¯‰
â”œâ”€â”€ [ ] Professional ãƒ—ãƒ©ãƒ³è¨­å®šãƒ»ãƒ†ã‚¹ãƒˆ
â””â”€â”€ [ ] æœ¬ç•ªãƒ‡ãƒ—ãƒ­ã‚¤æº–å‚™ãƒ»æ‰‹é †ç¢ºç«‹

ğŸŸ¡ é‡è¦å®Ÿè£…:
â”œâ”€â”€ [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
â”œâ”€â”€ [ ] ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹æ©Ÿèƒ½
â”œâ”€â”€ [ ] ç½å®³å¾©æ—§ãƒ»ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½“åˆ¶
â””â”€â”€ [ ] é‹ç”¨ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒ»ã‚µãƒãƒ¼ãƒˆä½“åˆ¶
```

---

## ğŸ¯ **Sunoå®Ÿè£…æˆåŠŸã¸ã®ç¢ºä¿¡**

### **âš¡ Sunoæ§˜ã¸ã®æœ€çµ‚æŒ‡ç¤º**

**åŠ›å¼·ãé ˆä½ä¹‹ç”· Sunoæ§˜ã€**

ã“ã®è©³ç´°ãªå®Ÿè£…æŒ‡ç¤ºæ›¸ã«ã‚ˆã‚Šã€**é©å‘½çš„ãªAIã‚¯ãƒ¬ã‚¸ãƒƒãƒˆåˆ¶CRMã‚·ã‚¹ãƒ†ãƒ **ã®å®Ÿç¾ãŒç¢ºå®Ÿã«ãªã‚Šã¾ã—ãŸã€‚

#### **ğŸŒŸ SunoãŒå‰µé€ ã™ã‚‹ä¾¡å€¤**
1. **æ¥­ç•Œé©æ–°**: æœˆÂ¥7,800ã‹ã‚‰ã®é©æ–°çš„ä¾¡æ ¼ã§ãƒ›ãƒ†ãƒ«æ¥­ç•Œãƒ‡ã‚¸ã‚¿ãƒ«åŒ–
2. **åç›Šçˆ†ç™º**: å¹´é–“Â¥213,840,000ï¼ˆå¾“æ¥æ¯”+103%ï¼‰ã®æŒç¶šå¯èƒ½é«˜åç›Š
3. **æŠ€è¡“é©æ–°**: AIã‚¯ãƒ¬ã‚¸ãƒƒãƒˆå¾“é‡èª²é‡‘åˆ¶ã®æ¥­ç•Œæ–°ã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰
4. **é¡§å®¢æº€è¶³**: å…¬å¹³ã§é€æ˜æ€§ã®é«˜ã„èª²é‡‘ã‚·ã‚¹ãƒ†ãƒ 

#### **âš¡ å®Ÿè£…ã®ç¢ºå®Ÿæ€§**
- **è©³ç´°æŠ€è¡“ä»•æ§˜**: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰UIã¾ã§å®Œå…¨è¨­è¨ˆ
- **æ®µéšçš„è¨ˆç”»**: 9é€±é–“ã®æ˜ç¢ºãªãƒ•ã‚§ãƒ¼ã‚ºåˆ†ã‘ã§ç¢ºå®Ÿå®Ÿè¡Œ
- **FastAPIç‰¹åŒ–**: Sunoã®æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ã«å®Œå…¨é©åˆ
- **ãƒ‘ã‚¤ãƒ­ãƒƒãƒˆç¢ºå®š**: æ£®è—¤æ°ï¼ˆProfessional ãƒ—ãƒ©ãƒ³ï¼‰ã§å®Ÿè¨¼

#### **ğŸ¯ æˆåŠŸã¸ã®é“ç­‹**
- **Week 1-2**: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ»åŸºç›¤æ§‹ç¯‰ï¼ˆåœŸå°å›ºã‚ï¼‰
- **Week 3-5**: AIæ©Ÿèƒ½ãƒ»æ±ºæ¸ˆã‚·ã‚¹ãƒ†ãƒ ï¼ˆã‚³ã‚¢ä¾¡å€¤å‰µé€ ï¼‰
- **Week 6-9**: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»é‹ç”¨æº–å‚™ï¼ˆä¿¡é ¼æ€§ç¢ºä¿ï¼‰

**âš¡ é ˆä½ä¹‹ç”·ã®åŠ›ã§ã€ãƒ›ãƒ†ãƒ«æ¥­ç•Œã‚’å®ˆè­·ã—ã€é©æ–°çš„CRMã‚·ã‚¹ãƒ†ãƒ ã‚’å‰µé€ ã—ã¦ãã ã•ã„ï¼**

**ç¾å ´ã«æ„›ã•ã‚Œã€é¡§å®¢ã«æ„Ÿè¬ã•ã‚Œã€äº‹æ¥­ã¨ã—ã¦æˆåŠŸã™ã‚‹æœ€é«˜ã®ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿç¾ã‚’ç¢ºä¿¡ã—ã¦ã„ã¾ã™ï¼**

---

**ğŸ“… å®Ÿè£…é–‹å§‹**: å³åº§é–‹å§‹æ¨å¥¨  
**ãƒ‘ã‚¤ãƒ­ãƒƒãƒˆé–‹å§‹**: Week 4  
**æœ¬æ ¼é‹ç”¨**: Week 9  
**ç›®æ¨™åç›Š**: å¹´é–“Â¥200,000,000è¶…

**ğŸ”¥ å®ˆè­·ç¥ã®åŠ›ã§ã€æ¥­ç•Œã‚’å¤‰é©ã™ã‚‹å®Ÿè£…ã‚’ãŠé¡˜ã„ã„ãŸã—ã¾ã™ï¼** 