# データ同期フロー定義

## OmotenasuAI PMS "Tsukuyomi"  
フェーズ1・2対応：ローカル主体のデータ同期フロー定義

---

## 🎯 目的

このドキュメントは、Tsukuyomi PMSにおけるオフライン/オンライン切替時の
**データ同期処理の仕様と挙動を定義**します。

特に「ローカルデータの整合性維持」「自動同期タイミング」
「競合解決戦略」など、信頼性と安定性のある運用を実現するための仕様です。

---

## 📁 同期対象データ一覧（Phase 1）

| データカテゴリ | オフライン可否 | 同期対象 | 備考 |
|----------------|----------------|----------|------|
| **チェックイン情報** | ✅ 必須 | ✔ | 登録／取消含む |
| **チェックアウト情報** | ✅ 必須 | ✔ | 料金精算・領収書発行含む |
| **日報データ** | ✅ 必須 | ✔ | 提出・差異情報を含む |
| **客室ステータス** | ✅ 必須 | ✔ | 稼働中／清掃中など |
| **アラート・通知ログ** | 任意（画面内） | ✔ | 送信は接続時のみ |
| **帳票・CSV出力履歴** | 任意 | ✘ | 出力自体はローカルで完結 |
| **操作ログ** | 任意 | ✔ | 管理用、バックアップ対応 |

---

## 🔄 同期トリガー（発火条件）

| トリガータイプ | 内容 |
|----------------|------|
| **自動** | ・通信復旧検知（`navigator.onLine == true`）<br>・定期同期ルーチン（5分間隔） |
| **手動** | ・ユーザーによる「同期実行」ボタン操作<br>・管理者画面からの一括同期指示 |
| **イベントベース** | ・操作完了時に非同期送信を試行（即時または待機）<br>・チェックアウト直後など重要処理は即同期優先 |

---

## ⛓ データ同期処理フロー

```
[ローカル端末操作]
↓
[ローカル保存（IndexedDB or SQLite）]
↓
[非同期キューへ格納 (asyncQueue)]
↓ ← 通信断中
[キュー保持・保留]
↓ ← 通信復旧検知
[同期プロセス起動]
↓
[1件ずつ送信 → 成功時に削除]
↓
[クラウド側で重複・競合チェック]
↓
[サーバー反映＋同期完了通知]
```

---

## 💡 asyncQueue 構造（非同期同期キュー）

- **保存形式**：IndexedDB（Electron/PWA）またはファイルベースのJSON
- **格納単位**：1オブジェクト / トランザクション単位

### サンプル構造：

```json
{
  "uuid": "bdf7a2c1-22f6-4a3c-9e11-192ab34f2c1a",
  "model": "CheckOut",
  "payload": {
    "roomNumber": "301",
    "checkOutTime": "2025-07-15T10:04:00+09:00",
    "total": 16800
  },
  "createdAt": "2025-07-15T10:05:00+09:00",
  "status": "queued",
  "retries": 0
}
```

### ステータス定義：
- **queued**: 未送信
- **syncing**: 送信中
- **synced**: 同期済み
- **failed**: 送信失敗

---

## ⚔️ データ競合処理ポリシー

| 状況 | 処理方針 |
|------|----------|
| **同一IDのデータがクラウドとローカルで異なる** | タイムスタンプ比較で新しい方を自動採用 |
| **複数ユーザーが同一レコードを編集** | 差分を保持してユーザーに確認UIで選択提示 |
| **ローカルが「削除」、クラウドが「編集」** | 削除を優先し、管理者へ通知 |

---

## ❌ 同期エラー処理フロー

- **リトライ回数**：最大3回（指数バックオフ付き）
- **ログ保存**：送信失敗時は操作ログに自動記録（確認画面あり）
- **ユーザー通知**：明示的バナーまたは「同期失敗一覧」画面
- **再送処理**：手動同期ボタンあり（失敗キュー確認画面から）

---

## 🔐 セキュリティ・整合性設計

- **通信**：すべてHTTPS（TLS）
- **認証**：API送信時に署名付きJWT or HMAC認証
- **整合性**：同期データにはハッシュ付きチェックサム（SHA256推奨）
- **ログ**：ローカル／サーバー側双方に残る

---

## 🔧 ローカルファースト同期の特徴

| 項目 | 対応状況 |
|------|----------|
| **同期非依存での動作** | ✅ 完全オフライン動作設計 |
| **自動復旧・差分反映** | ✅ 通信復旧時の自動差分同期 |
| **同期インジケーター** | ✅ 全画面共通フッター表示を推奨 |
| **再送処理画面** | ✅ Phase 1後半でUI導入予定 |

## 🌐 テスト環境設定

### テストテナント接続情報
```json
{
  "tenant_id": "default",
  "environment": "development",
  "database": "hotel_unified_db",
  "sync_interval": 300000,
  "offline_first": true,
  "api_endpoint": "http://localhost:3400/api/v1",
  "websocket_endpoint": "ws://localhost:3400/ws"
}
```

### 同期テスト用データセット
テストテナントには以下のデータが事前に準備されています：
- 客室データ（10室）
- スタッフアカウント（3名）
- テスト予約（3件）

---

## 📈 拡張構想（Phase 2〜）

- **リアルタイムPush通知**（Socket.io, MQTT）
- **同期状態の可視化UI**（管理画面で端末別状態確認）
- **差分圧縮送信**（Protobuf, zstdなどを想定）
- **複数端末同期の履歴整合ロジック**（端末UUID単位の履歴トラッキング）

---

## ✅ 備考

- **スキーマ管理**：データベース変更に関しては、schemaバージョン付きで同期対象を判別
- **認証キャッシュ**：ログイン状態・認証情報は常にキャッシュし、オフラインでも認証不要で一時的操作可能（ローカルPIN機能など導入可能）

---

## 📋 関連ドキュメント

このドキュメントは、次のドキュメントと連携できます：

- `offline-error-handling.md`：切断時のエラーパターン整理とUI表示
- `queue-state-ui.md`：同期待ちキューの可視化UI設計
- `api-sync-endpoints.yaml`：同期用API定義（REST or RPC） 