# 開発ルール

## 依存関係管理ルール（最重要）

### 基本方針
- 動作しているコードの依存関係は安易に変更しない
- パッケージのバージョンは必ず固定（^や~を使用しない）
- 変更前には必ず現在の状態をバックアップ

### パッケージ追加時のルール
```bash
# 新規パッケージ追加時は必ず--save-exactを使用
pnpm add --save-exact パッケージ名@バージョン

# 例：
pnpm add --save-exact @sidebase/nuxt-auth@0.10.1
```

### package.jsonの記述ルール
```json
{
  "dependencies": {
    // バージョンは必ず固定（^や~を使用しない）
    "@sidebase/nuxt-auth": "0.10.1",
    "next-auth": "4.21.1"
  },
  "engines": {
    // 実行環境のバージョンも固定
    "node": ">=18.0.0",
    "pnpm": ">=8.0.0"
  }
}
```

### 変更前の確認手順
```bash
# 1. 現在の依存関係を確認
pnpm list

# 2. 更新可能なパッケージを確認
pnpm outdated

# 3. 特定のパッケージの依存関係を確認
pnpm why パッケージ名
```

### 禁止事項
- 動作しているコードの依存関係を安易に変更しない
- パッケージのバージョンを範囲指定（^や~）で記述しない
- テスト環境での確認なしに本番環境に適用しない

### 変更が必要な場合の手順
1. 現在の動作している状態の`package.json`と`pnpm-lock.yaml`をバックアップ
2. 変更内容と理由を明確に記録
3. テスト環境で動作確認
4. 問題が発生した場合は即座に元の状態に戻せるようにする

## 開発時の確認事項

### 必須把握事項
- プロジェクトの構造と主要ファイルの役割
- 認証フローの実装方法
- エラーハンドリングの方法
- テストの実行方法
- デプロイメントプロセス

### 開発時の確認手順
1. 変更前の現在の状態の把握
2. 変更の影響範囲の確認
3. テスト環境での動作確認
4. エラー発生時のロールバック手順

## データ削除ルール

### 基本方針：論理削除（ソフトデリート）の採用

システム内のデータは原則として**物理削除ではなく論理削除**を使用します。これにより、履歴データの参照整合性を維持し、誤削除からの復旧を容易にします。

### 実装要件

1. **全エンティティ共通の論理削除フィールド**
   ```
   isDeleted  Boolean  @default(false)  // 論理削除フラグ
   deletedAt  DateTime?               // 削除日時
   ```

2. **クエリ時の考慮事項**
   - 通常の検索・一覧表示では、`isDeleted: false`のものだけを表示
   - 履歴参照時は削除済みデータも含めて関連データを取得可能に
   - 管理画面には削除済みデータの表示/非表示を切り替える機能を実装

3. **UI表示の工夫**
   - 削除済みデータを表示する際は「[削除済み]」などの表示を追加
   - 履歴データなど、関連データの表示時にも削除状態を明示

### 論理削除の実装例

```typescript
// 論理削除関数の例
async function softDelete(model, id) {
  return await prisma[model].update({
    where: { id },
    data: { 
      isDeleted: true,
      deletedAt: new Date()
    }
  });
}

// クエリ時の例
async function findActive(model, conditions = {}) {
  return await prisma[model].findMany({
    where: { 
      ...conditions,
      isDeleted: false 
    }
  });
}
```

### 例外的な物理削除

以下の場合のみ、例外的に物理削除を検討可能：

1. 個人情報保護法などの法的要件に基づく削除要請
2. 一時的なテストデータ
3. システム内部でのみ使用され、外部から参照されない一時データ

物理削除を行う場合は、必ず事前に関連データへの影響を確認し、チームの承認を得ること。

## エラー処理・バリデーションルール

### フロントエンドのエラー表示
1. **ブラウザのアラート(`window.alert()`)は使用禁止**
   - すべてのエラーは統一されたUIコンポーネント内に表示すること
   - アラートの代わりに`useToast`またはインラインエラーメッセージを使用

2. **リアルタイムバリデーション**
   - 可能な限り入力中または入力欄からフォーカスが外れた時点で検証
   - 複雑な検証（API連携必要なもの）は適切なタイミングで非同期に実行

3. **送信ボタンの状態管理**
   - バリデーションエラーがある場合は送信ボタンを無効化
   - 必須入力項目が未入力の場合も送信ボタンを無効化
   - 送信中は送信ボタンの状態を「送信中...」に変更し、多重送信を防止

4. **エラー表示場所**
   - 各フィールドのエラー: 対応する入力フィールドの直下
   - API応答エラー: フォーム上部または送信ボタン上部にまとめて表示

### バックエンドのエラー処理
1. **APIエラーの統一フォーマット**
   - すべてのAPIエラーは以下の形式で返す:
   ```json
   {
     "statusCode": 400,
     "message": "エラーメッセージ",
     "data": { ... } // 追加情報（オプション）
   }
   ```

2. **バリデーションエラーの詳細情報**
   - Zodなどのバリデーションライブラリによるエラーは詳細をdataに含める
   - クライアント側でフィールド単位のエラー表示に利用可能な形式で返す

3. **多言語対応エラーメッセージ**
   - エラーメッセージは日本語と英語の両方を用意
   - クライアントの言語設定に応じて適切な言語で表示

### 重複チェックの実装
1. **一意性制約のある項目**
   - IPアドレス、MACアドレス、ユーザーIDなどは作成・更新時に重複チェック
   - 重複チェックはアクティブ・非アクティブを問わずすべてのレコードに対して実施
   - 空値や無効値の場合は明示的にチェックをスキップするロジックを追加

2. **重複チェックのタイミング**
   - 可能な限りフォームの送信前にAPI経由で重複チェック実施
   - 最終的な保存処理でも重複チェックを行い、競合状態を防止

## 更新履歴
- 2025-05-15: データ削除ルール（論理削除）を追加
- 2025-05-14: エラー処理・バリデーションルールを追加
- 2024-03-19: 依存関係管理ルールを追加 