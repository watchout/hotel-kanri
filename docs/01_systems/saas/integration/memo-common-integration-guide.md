# hotel-saas ãƒ¡ãƒ¢æ©Ÿèƒ½ hotel-commonçµ±åˆã‚¬ã‚¤ãƒ‰

**ä½œæˆæ—¥**: 2025å¹´9æœˆ16æ—¥  
**ä½œæˆè€…**: kaneko (hotel-kanri)  
**å¯¾è±¡ã‚·ã‚¹ãƒ†ãƒ **: hotel-saas  
**æ©Ÿèƒ½**: hotel-commonã®ãƒ¡ãƒ¢æ©Ÿèƒ½çµ±åˆå®Ÿè£…ã‚¬ã‚¤ãƒ‰

## ğŸš¨ **é‡è¦ãªå®Ÿè£…æ–¹é‡**

### **âŒ ç¦æ­¢äº‹é …ï¼ˆå³å®ˆï¼‰**

**ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ»ãƒ¢ãƒƒã‚¯ãƒ»ä¸€æ™‚å¯¾å¿œã®å…¨é¢ç¦æ­¢**
- âŒ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†ï¼ˆã‚¨ãƒ©ãƒ¼æ™‚ã®ä»£æ›¿å‡¦ç†ï¼‰
- âŒ ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã®ä½¿ç”¨
- âŒ ä¸€æ™‚çš„ãªå›é¿å®Ÿè£…
- âŒ try-catch ã§ã®ä¾‹å¤–éš è”½
- âŒ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã§ã®å•é¡Œå›é¿
- âŒ ã€Œã¨ã‚Šã‚ãˆãšå‹•ãã€å®Ÿè£…

**ç†ç”±**:
- ã‚¨ãƒ©ãƒ¼ã®éš è”½ã«ã‚ˆã‚Šå•é¡Œç™ºè¦‹ãŒå›°é›£
- ä¸€æ™‚å¯¾å¿œã®æ’ä¹…åŒ–ã«ã‚ˆã‚‹æŠ€è¡“çš„è² å‚µ
- ã‚·ã‚¹ãƒ†ãƒ æ•´åˆæ€§ã®ç ´ç¶»
- ãƒ‡ãƒãƒƒã‚°å›°é›£åŒ–

### **âœ… å¿…é ˆäº‹é …**

**æ­£é¢ã‹ã‚‰ã®å•é¡Œè§£æ±º**
- âœ… ã‚¨ãƒ©ãƒ¼ã¯å¿…ãšè¡¨é¢åŒ–ã•ã›ã‚‹
- âœ… å•é¡Œã®æ ¹æœ¬åŸå› ã‚’ç‰¹å®šãƒ»è§£æ±º
- âœ… é©åˆ‡ãªã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼ˆéš è”½ã§ã¯ãªã„ï¼‰
- âœ… å®Ÿè£…å‰ã®ä¾å­˜é–¢ä¿‚ç¢ºèª
- âœ… æ®µéšçš„ã ãŒç¢ºå®Ÿãªå®Ÿè£…

## ğŸ“‹ çµ±åˆæ¦‚è¦

hotel-saasã®æ—¢å­˜ãƒ¡ãƒ¢æ©Ÿèƒ½ã‚’ã€hotel-commonã®å…±æœ‰ãƒ¡ãƒ¢ã‚·ã‚¹ãƒ†ãƒ ã«çµ±åˆã—ã¾ã™ã€‚

### çµ±åˆå¾Œã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         hotel-saas              â”‚
â”‚                                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚    Frontend Components      â”‚ â”‚
â”‚ â”‚  - MemoList.vue             â”‚ â”‚
â”‚ â”‚  - MemoDetail.vue           â”‚ â”‚
â”‚ â”‚  - MemoEditModal.vue        â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚               â”‚                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚      Composables          â”‚   â”‚
â”‚ â”‚  - useMemoApi.ts          â”‚   â”‚
â”‚ â”‚  - useReadStatus.ts       â”‚   â”‚
â”‚ â”‚  - useNotifications.ts    â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚               â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚ HTTP/REST API
                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        hotel-common             â”‚
â”‚                                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚     Memo API Service        â”‚ â”‚
â”‚ â”‚  - /api/v1/memos/*          â”‚ â”‚
â”‚ â”‚  - Authentication           â”‚ â”‚
â”‚ â”‚  - Authorization            â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚               â”‚                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚       Database            â”‚   â”‚
â”‚ â”‚  - memos                  â”‚   â”‚
â”‚ â”‚  - memo_comments          â”‚   â”‚
â”‚ â”‚  - memo_read_statuses     â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”§ å®Ÿè£…æ‰‹é †

### Phase 1: ç’°å¢ƒè¨­å®šãƒ»ä¾å­˜é–¢ä¿‚ç¢ºèª

#### 1.1 hotel-common APIæ¥ç¶šè¨­å®š

**nuxt.config.ts ã®æ›´æ–°**:
```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  runtimeConfig: {
    public: {
      // hotel-common APIè¨­å®š
      hotelCommonApiUrl: process.env.HOTEL_COMMON_API_URL || 'http://localhost:3400',
      hotelCommonWsUrl: process.env.HOTEL_COMMON_WS_URL || 'ws://localhost:3400'
    }
  },
  
  // hotel-common ã¸ã® API ãƒ—ãƒ­ã‚­ã‚·è¨­å®šï¼ˆé–‹ç™ºç’°å¢ƒç”¨ï¼‰
  nitro: {
    devProxy: {
      '/api/common': {
        target: 'http://localhost:3400/api/v1',
        changeOrigin: true,
        pathRewrite: { '^/api/common': '' }
      }
    }
  }
})
```

#### 1.2 ç’°å¢ƒå¤‰æ•°è¨­å®š

**.env ãƒ•ã‚¡ã‚¤ãƒ«**:
```bash
# hotel-common APIè¨­å®š
HOTEL_COMMON_API_URL=http://localhost:3400
HOTEL_COMMON_WS_URL=ws://localhost:3400

# èªè¨¼è¨­å®š
HOTEL_COMMON_API_TIMEOUT=30000
HOTEL_COMMON_MAX_RETRIES=3
```

#### 1.3 ä¾å­˜é–¢ä¿‚ç¢ºèªãƒã‚§ãƒƒã‚¯

```typescript
// utils/systemHealthCheck.ts
export const checkHotelCommonConnection = async (): Promise<boolean> => {
  try {
    const config = useRuntimeConfig();
    const response = await fetch(`${config.public.hotelCommonApiUrl}/health`, {
      method: 'GET',
      timeout: 5000
    });
    
    if (!response.ok) {
      throw new Error(`hotel-common health check failed: ${response.status}`);
    }
    
    return true;
  } catch (error) {
    console.error('hotel-common connection failed:', error);
    throw new Error(`hotel-common is not available: ${error.message}`);
  }
};

// ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•æ™‚ã®ãƒã‚§ãƒƒã‚¯
// plugins/system-check.client.ts
export default defineNuxtPlugin(async () => {
  try {
    await checkHotelCommonConnection();
    console.log('âœ… hotel-common connection verified');
  } catch (error) {
    console.error('âŒ hotel-common connection failed:', error);
    throw error; // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•ã‚’åœæ­¢
  }
});
```

### Phase 2: APIçµ±åˆãƒ¬ã‚¤ãƒ¤ãƒ¼å®Ÿè£…

#### 2.1 å…±é€šAPIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ

```typescript
// composables/useHotelCommonApi.ts
export const useHotelCommonApi = () => {
  const config = useRuntimeConfig();
  const { staff } = useJwtAuth();
  
  const apiClient = $fetch.create({
    baseURL: `${config.public.hotelCommonApiUrl}/api/v1`,
    timeout: config.public.hotelCommonApiTimeout || 30000,
    
    onRequest({ request, options }) {
      // èªè¨¼ãƒ˜ãƒƒãƒ€ãƒ¼è¨­å®š
      if (!staff.value?.id) {
        throw new Error('Staff authentication required for hotel-common API');
      }
      
      const token = useCookie('auth-token').value;
      if (!token) {
        throw new Error('Authentication token not found');
      }
      
      options.headers = {
        ...options.headers,
        'Authorization': `Bearer ${token}`,
        'X-Source-System': 'saas',
        'X-Tenant-ID': staff.value.tenantId,
        'Content-Type': 'application/json'
      };
    },
    
    onRequestError({ request, error }) {
      console.error('hotel-common API request error:', error);
      throw new Error(`API request failed: ${error.message}`);
    },
    
    onResponseError({ request, response }) {
      console.error('hotel-common API response error:', response.status, response._data);
      
      if (response.status === 401) {
        throw new Error('Authentication failed with hotel-common');
      }
      
      if (response.status === 403) {
        throw new Error('Access denied by hotel-common');
      }
      
      if (response.status >= 500) {
        throw new Error('hotel-common server error');
      }
      
      throw new Error(`API error: ${response._data?.error?.message || 'Unknown error'}`);
    }
  });
  
  return { apiClient };
};
```

#### 2.2 ãƒ¡ãƒ¢API Composable

```typescript
// composables/useMemoApi.ts
export const useMemoApi = () => {
  const { apiClient } = useHotelCommonApi();
  const { staff } = useJwtAuth();
  
  // ãƒ¡ãƒ¢ä¸€è¦§å–å¾—
  const fetchMemos = async (params: MemoListParams = {}) => {
    if (!staff.value?.id) {
      throw new Error('Staff authentication required');
    }
    
    try {
      const response = await apiClient('/memos', {
        method: 'GET',
        query: {
          includeReadStatus: true,
          staffId: staff.value.id,
          sourceSystem: 'saas',
          ...params
        }
      });
      
      return response.data;
    } catch (error) {
      console.error('Failed to fetch memos:', error);
      throw new Error(`ãƒ¡ãƒ¢ä¸€è¦§å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
    }
  };
  
  // ãƒ¡ãƒ¢è©³ç´°å–å¾—
  const fetchMemoDetail = async (memoId: string, options: MemoDetailOptions = {}) => {
    if (!staff.value?.id) {
      throw new Error('Staff authentication required');
    }
    
    try {
      const response = await apiClient(`/memos/${memoId}`, {
        method: 'GET',
        query: {
          includeReadStatus: true,
          staffId: staff.value.id,
          autoMarkAsRead: true,
          ...options
        }
      });
      
      return response.data;
    } catch (error) {
      console.error('Failed to fetch memo detail:', error);
      throw new Error(`ãƒ¡ãƒ¢è©³ç´°å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
    }
  };
  
  // ãƒ¡ãƒ¢ä½œæˆ
  const createMemo = async (memoData: CreateMemoData) => {
    if (!staff.value?.id) {
      throw new Error('Staff authentication required');
    }
    
    try {
      const response = await apiClient('/memos', {
        method: 'POST',
        body: {
          ...memoData,
          authorId: staff.value.id,
          sourceSystem: 'saas'
        }
      });
      
      return response.data;
    } catch (error) {
      console.error('Failed to create memo:', error);
      throw new Error(`ãƒ¡ãƒ¢ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
    }
  };
  
  // ãƒ¡ãƒ¢æ›´æ–°
  const updateMemo = async (memoId: string, updates: UpdateMemoData) => {
    if (!staff.value?.id) {
      throw new Error('Staff authentication required');
    }
    
    try {
      const response = await apiClient(`/memos/${memoId}`, {
        method: 'PATCH',
        body: updates
      });
      
      return response.data;
    } catch (error) {
      console.error('Failed to update memo:', error);
      throw new Error(`ãƒ¡ãƒ¢æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
    }
  };
  
  // ãƒ¡ãƒ¢å‰Šé™¤
  const deleteMemo = async (memoId: string) => {
    if (!staff.value?.id) {
      throw new Error('Staff authentication required');
    }
    
    try {
      const response = await apiClient(`/memos/${memoId}`, {
        method: 'DELETE'
      });
      
      return response.data;
    } catch (error) {
      console.error('Failed to delete memo:', error);
      throw new Error(`ãƒ¡ãƒ¢å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
    }
  };
  
  return {
    fetchMemos,
    fetchMemoDetail,
    createMemo,
    updateMemo,
    deleteMemo
  };
};
```

#### 2.3 æ—¢èª­ç®¡ç† Composable

```typescript
// composables/useReadStatus.ts
export const useReadStatus = () => {
  const { apiClient } = useHotelCommonApi();
  const { staff } = useJwtAuth();
  
  // æ—¢èª­å‡¦ç†
  const markAsRead = async (targetType: 'memo' | 'comment', targetId: string, readTimeSeconds?: number) => {
    if (!staff.value?.id) {
      throw new Error('Staff authentication required');
    }
    
    try {
      const response = await apiClient('/memos/read-status', {
        method: 'POST',
        body: {
          targetType,
          targetId,
          staffId: staff.value.id,
          readTimeSeconds
        }
      });
      
      return response.data;
    } catch (error) {
      console.error('Failed to mark as read:', error);
      throw new Error(`æ—¢èª­å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
    }
  };
  
  // ä¸€æ‹¬æ—¢èª­å‡¦ç†
  const markMultipleAsRead = async (items: Array<{targetType: 'memo' | 'comment', targetId: string}>) => {
    if (!staff.value?.id) {
      throw new Error('Staff authentication required');
    }
    
    try {
      const response = await apiClient('/memos/read-status/batch', {
        method: 'POST',
        body: {
          staffId: staff.value.id,
          items
        }
      });
      
      return response.data;
    } catch (error) {
      console.error('Failed to mark multiple as read:', error);
      throw new Error(`ä¸€æ‹¬æ—¢èª­å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
    }
  };
  
  // æœªèª­æ•°å–å¾—
  const getUnreadCount = async (includeDetails = false) => {
    if (!staff.value?.id) {
      throw new Error('Staff authentication required');
    }
    
    try {
      const response = await apiClient('/memos/unread-count', {
        method: 'GET',
        query: {
          staffId: staff.value.id,
          includeDetails,
          sourceSystem: 'saas'
        }
      });
      
      return response.data;
    } catch (error) {
      console.error('Failed to get unread count:', error);
      throw new Error(`æœªèª­æ•°å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
    }
  };
  
  return {
    markAsRead,
    markMultipleAsRead,
    getUnreadCount
  };
};
```

### Phase 3: ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰çµ±åˆ

#### 3.1 ãƒ¡ãƒ¢ä¸€è¦§ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆæ›´æ–°

```vue
<!-- components/MemoList.vue -->
<template>
  <div class="memo-list">
    <div class="memo-list-header">
      <h2>ãƒ¡ãƒ¢ä¸€è¦§</h2>
      <div class="unread-summary">
        <span v-if="unreadCount > 0" class="unread-badge">
          æœªèª­: {{ unreadCount }}ä»¶
        </span>
      </div>
    </div>
    
    <div class="memo-filters">
      <button 
        @click="toggleUnreadFilter"
        :class="{ active: showUnreadOnly }"
        class="filter-btn"
      >
        æœªèª­ã®ã¿è¡¨ç¤º
      </button>
      
      <select v-model="selectedPriority" @change="applyFilters" class="priority-filter">
        <option value="">ã™ã¹ã¦ã®å„ªå…ˆåº¦</option>
        <option value="high">é«˜</option>
        <option value="medium">ä¸­</option>
        <option value="low">ä½</option>
      </select>
    </div>
    
    <div v-if="loading" class="loading">
      ãƒ¡ãƒ¢ã‚’èª­ã¿è¾¼ã¿ä¸­...
    </div>
    
    <div v-else-if="error" class="error">
      {{ error }}
    </div>
    
    <div v-else class="memo-items">
      <MemoListItem 
        v-for="memo in memos" 
        :key="memo.id"
        :memo="memo"
        @click="navigateToMemo(memo.id)"
      />
    </div>
    
    <div v-if="pagination.hasNext" class="load-more">
      <button @click="loadMore" :disabled="loadingMore">
        {{ loadingMore ? 'èª­ã¿è¾¼ã¿ä¸­...' : 'ã•ã‚‰ã«èª­ã¿è¾¼ã‚€' }}
      </button>
    </div>
  </div>
</template>

<script setup lang="ts">
const { fetchMemos } = useMemoApi();
const { getUnreadCount } = useReadStatus();

const memos = ref([]);
const loading = ref(false);
const loadingMore = ref(false);
const error = ref('');
const unreadCount = ref(0);
const showUnreadOnly = ref(false);
const selectedPriority = ref('');
const pagination = ref({ hasNext: false, page: 1 });

// ãƒ¡ãƒ¢ä¸€è¦§å–å¾—
const loadMemos = async (reset = true) => {
  try {
    if (reset) {
      loading.value = true;
      pagination.value.page = 1;
    } else {
      loadingMore.value = true;
    }
    
    const response = await fetchMemos({
      page: pagination.value.page,
      pageSize: 20,
      filterUnreadOnly: showUnreadOnly.value,
      priority: selectedPriority.value || undefined,
      sortBy: 'updatedAt',
      sortOrder: 'desc'
    });
    
    if (reset) {
      memos.value = response.memos;
    } else {
      memos.value.push(...response.memos);
    }
    
    pagination.value = response.pagination;
    unreadCount.value = response.summary.totalUnreadCount;
    
  } catch (err) {
    console.error('Failed to load memos:', err);
    error.value = err.message;
  } finally {
    loading.value = false;
    loadingMore.value = false;
  }
};

// ã•ã‚‰ã«èª­ã¿è¾¼ã‚€
const loadMore = async () => {
  pagination.value.page++;
  await loadMemos(false);
};

// ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨
const applyFilters = () => {
  loadMemos(true);
};

// æœªèª­ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼åˆ‡ã‚Šæ›¿ãˆ
const toggleUnreadFilter = () => {
  showUnreadOnly.value = !showUnreadOnly.value;
  applyFilters();
};

// ãƒ¡ãƒ¢è©³ç´°ã¸é·ç§»
const navigateToMemo = (memoId: string) => {
  navigateTo(`/memos/${memoId}`);
};

// åˆæœŸèª­ã¿è¾¼ã¿
onMounted(() => {
  loadMemos();
});

// ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°ï¼ˆWebSocketï¼‰
const { connect: connectNotifications } = useNotifications();
onMounted(() => {
  connectNotifications((notification) => {
    if (notification.type === 'memo_created' || notification.type === 'memo_updated') {
      // ãƒ¡ãƒ¢ä¸€è¦§ã‚’å†èª­ã¿è¾¼ã¿
      loadMemos(true);
    }
  });
});
</script>

<style scoped>
.memo-list {
  @apply space-y-4;
}

.memo-list-header {
  @apply flex justify-between items-center;
}

.unread-badge {
  @apply bg-red-500 text-white px-3 py-1 rounded-full text-sm font-semibold;
}

.memo-filters {
  @apply flex gap-4 items-center;
}

.filter-btn {
  @apply px-4 py-2 border border-gray-300 rounded-md hover:bg-gray-50;
}

.filter-btn.active {
  @apply bg-blue-500 text-white border-blue-500;
}

.priority-filter {
  @apply px-3 py-2 border border-gray-300 rounded-md;
}

.loading, .error {
  @apply text-center py-8 text-gray-600;
}

.error {
  @apply text-red-600;
}

.memo-items {
  @apply space-y-3;
}

.load-more {
  @apply text-center;
}

.load-more button {
  @apply px-6 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 disabled:opacity-50;
}
</style>
```

#### 3.2 ãƒ¡ãƒ¢è©³ç´°ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆæ›´æ–°

```vue
<!-- pages/memos/[id].vue -->
<template>
  <div class="memo-detail-page">
    <div v-if="loading" class="loading">
      ãƒ¡ãƒ¢ã‚’èª­ã¿è¾¼ã¿ä¸­...
    </div>
    
    <div v-else-if="error" class="error">
      {{ error }}
    </div>
    
    <div v-else class="memo-detail">
      <!-- ãƒ¡ãƒ¢æœ¬ä½“ -->
      <div class="memo-content" :class="{ 'unread': !memo.readStatus?.isRead }">
        <div class="memo-header">
          <h1>{{ memo.title }}</h1>
          <div class="memo-actions">
            <button @click="editMemo" class="edit-btn">ç·¨é›†</button>
            <button @click="deleteMemo" class="delete-btn">å‰Šé™¤</button>
          </div>
        </div>
        
        <div class="memo-meta">
          <span class="author">{{ memo.authorName }}</span>
          <span class="date">{{ formatDate(memo.updatedAt) }}</span>
          <span class="system">{{ memo.sourceSystem.toUpperCase() }}</span>
          <span v-if="memo.priority !== 'medium'" class="priority" :class="memo.priority">
            {{ getPriorityLabel(memo.priority) }}
          </span>
        </div>
        
        <div class="memo-tags" v-if="memo.tags.length > 0">
          <span v-for="tag in memo.tags" :key="tag" class="tag">{{ tag }}</span>
        </div>
        
        <div class="memo-body">{{ memo.content }}</div>
        
        <!-- æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ« -->
        <div v-if="attachments.length > 0" class="attachments">
          <h3>æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«</h3>
          <div class="attachment-list">
            <div v-for="attachment in attachments" :key="attachment.id" class="attachment-item">
              <a :href="getAttachmentUrl(attachment.id)" target="_blank">
                {{ attachment.originalFilename }}
              </a>
              <span class="file-size">({{ formatFileSize(attachment.fileSize) }})</span>
            </div>
          </div>
        </div>
      </div>
      
      <!-- ã‚³ãƒ¡ãƒ³ãƒˆä¸€è¦§ -->
      <div class="comments-section">
        <h2>ã‚³ãƒ¡ãƒ³ãƒˆ ({{ comments.length }})</h2>
        
        <!-- ã‚³ãƒ¡ãƒ³ãƒˆä½œæˆãƒ•ã‚©ãƒ¼ãƒ  -->
        <div class="comment-form">
          <textarea 
            v-model="newComment" 
            placeholder="ã‚³ãƒ¡ãƒ³ãƒˆã‚’å…¥åŠ›..."
            class="comment-input"
          ></textarea>
          <button @click="addComment" :disabled="!newComment.trim()" class="submit-btn">
            ã‚³ãƒ¡ãƒ³ãƒˆæŠ•ç¨¿
          </button>
        </div>
        
        <!-- ã‚³ãƒ¡ãƒ³ãƒˆä¸€è¦§ -->
        <div class="comment-list">
          <div 
            v-for="comment in comments" 
            :key="comment.id"
            class="comment-item"
            :class="{ 'unread': !comment.readStatus?.isRead }"
          >
            <div class="comment-header">
              <span class="author">{{ comment.authorName }}</span>
              <span class="date">{{ formatDate(comment.createdAt) }}</span>
              <span class="system">{{ comment.sourceSystem.toUpperCase() }}</span>
              <UnreadIndicator 
                v-if="!comment.readStatus?.isRead"
                :unread-count="1"
                :show-count="false"
              />
            </div>
            <div class="comment-content">{{ comment.content }}</div>
            
            <!-- è¿”ä¿¡ä¸€è¦§ -->
            <div v-if="comment.replies.length > 0" class="replies">
              <div 
                v-for="reply in comment.replies"
                :key="reply.id"
                class="reply-item"
                :class="{ 'unread': !reply.readStatus?.isRead }"
              >
                <div class="reply-header">
                  <span class="author">{{ reply.authorName }}</span>
                  <span class="date">{{ formatDate(reply.createdAt) }}</span>
                  <span class="system">{{ reply.sourceSystem.toUpperCase() }}</span>
                </div>
                <div class="reply-content">{{ reply.content }}</div>
              </div>
            </div>
            
            <!-- è¿”ä¿¡ãƒ•ã‚©ãƒ¼ãƒ  -->
            <div class="reply-form">
              <textarea 
                v-model="replyTexts[comment.id]" 
                placeholder="è¿”ä¿¡ã‚’å…¥åŠ›..."
                class="reply-input"
              ></textarea>
              <button 
                @click="addReply(comment.id)" 
                :disabled="!replyTexts[comment.id]?.trim()"
                class="reply-btn"
              >
                è¿”ä¿¡
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
const route = useRoute();
const { fetchMemoDetail } = useMemoApi();
const { markAsRead, markMultipleAsRead } = useReadStatus();

const memo = ref({});
const comments = ref([]);
const attachments = ref([]);
const loading = ref(false);
const error = ref('');
const newComment = ref('');
const replyTexts = ref({});

// ãƒ¡ãƒ¢è©³ç´°å–å¾—
const loadMemoDetail = async () => {
  try {
    loading.value = true;
    
    const response = await fetchMemoDetail(route.params.id as string, {
      includeComments: true,
      includeAttachments: true,
      autoMarkAsRead: true
    });
    
    memo.value = response.memo;
    comments.value = response.comments || [];
    attachments.value = response.attachments || [];
    
    // è¡¨ç¤ºå¾Œã«æœªèª­ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ—¢èª­ã«ã™ã‚‹
    await markVisibleItemsAsRead();
    
  } catch (err) {
    console.error('Failed to load memo detail:', err);
    error.value = err.message;
  } finally {
    loading.value = false;
  }
};

// è¡¨ç¤ºã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ã‚’æ—¢èª­ã«ã™ã‚‹
const markVisibleItemsAsRead = async () => {
  const unreadItems = [];
  
  // ãƒ¡ãƒ¢æœ¬ä½“ãŒæœªèª­ã®å ´åˆ
  if (!memo.value.readStatus?.isRead) {
    unreadItems.push({
      targetType: 'memo',
      targetId: memo.value.id
    });
  }
  
  // æœªèª­ã‚³ãƒ¡ãƒ³ãƒˆãƒ»è¿”ä¿¡ã‚’åé›†
  comments.value.forEach(comment => {
    if (!comment.readStatus?.isRead) {
      unreadItems.push({
        targetType: 'comment',
        targetId: comment.id
      });
    }
    
    comment.replies?.forEach(reply => {
      if (!reply.readStatus?.isRead) {
        unreadItems.push({
          targetType: 'comment',
          targetId: reply.id
        });
      }
    });
  });
  
  // ä¸€æ‹¬æ—¢èª­å‡¦ç†
  if (unreadItems.length > 0) {
    try {
      await markMultipleAsRead(unreadItems);
    } catch (error) {
      console.error('Failed to mark items as read:', error);
      // ã‚¨ãƒ©ãƒ¼ã¯éš è”½ã›ãšã€ãƒ­ã‚°å‡ºåŠ›ã®ã¿
    }
  }
};

// ã‚³ãƒ¡ãƒ³ãƒˆè¿½åŠ 
const addComment = async () => {
  if (!newComment.value.trim()) return;
  
  try {
    const { createComment } = useMemoApi();
    await createComment(memo.value.id, {
      content: newComment.value.trim()
    });
    
    newComment.value = '';
    await loadMemoDetail(); // å†èª­ã¿è¾¼ã¿
  } catch (error) {
    console.error('Failed to add comment:', error);
    // ã‚¨ãƒ©ãƒ¼è¡¨ç¤º
    alert(`ã‚³ãƒ¡ãƒ³ãƒˆæŠ•ç¨¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
  }
};

// è¿”ä¿¡è¿½åŠ 
const addReply = async (commentId: string) => {
  const replyText = replyTexts.value[commentId];
  if (!replyText?.trim()) return;
  
  try {
    const { createComment } = useMemoApi();
    await createComment(memo.value.id, {
      content: replyText.trim(),
      parentCommentId: commentId
    });
    
    replyTexts.value[commentId] = '';
    await loadMemoDetail(); // å†èª­ã¿è¾¼ã¿
  } catch (error) {
    console.error('Failed to add reply:', error);
    alert(`è¿”ä¿¡æŠ•ç¨¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
  }
};

// ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
const formatDate = (dateString: string) => {
  return new Date(dateString).toLocaleDateString('ja-JP', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
};

const getPriorityLabel = (priority: string) => {
  const labels = { high: 'é«˜', medium: 'ä¸­', low: 'ä½' };
  return labels[priority] || priority;
};

const formatFileSize = (bytes: number) => {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return Math.round(bytes / 1024) + ' KB';
  return Math.round(bytes / (1024 * 1024)) + ' MB';
};

const getAttachmentUrl = (attachmentId: string) => {
  const config = useRuntimeConfig();
  return `${config.public.hotelCommonApiUrl}/api/v1/memos/attachments/${attachmentId}/download`;
};

// åˆæœŸèª­ã¿è¾¼ã¿
onMounted(() => {
  loadMemoDetail();
});
</script>

<style scoped>
.memo-detail-page {
  @apply max-w-4xl mx-auto p-6;
}

.loading, .error {
  @apply text-center py-8;
}

.error {
  @apply text-red-600;
}

.memo-content {
  @apply bg-white rounded-lg border p-6 mb-8;
}

.memo-content.unread {
  @apply border-red-200 bg-red-50;
}

.memo-header {
  @apply flex justify-between items-start mb-4;
}

.memo-actions {
  @apply flex gap-2;
}

.edit-btn, .delete-btn {
  @apply px-3 py-1 text-sm rounded;
}

.edit-btn {
  @apply bg-blue-500 text-white hover:bg-blue-600;
}

.delete-btn {
  @apply bg-red-500 text-white hover:bg-red-600;
}

.memo-meta {
  @apply flex gap-4 text-sm text-gray-600 mb-4;
}

.system {
  @apply bg-gray-100 px-2 py-1 rounded text-xs;
}

.priority.high {
  @apply bg-red-100 text-red-800 px-2 py-1 rounded text-xs;
}

.priority.low {
  @apply bg-green-100 text-green-800 px-2 py-1 rounded text-xs;
}

.memo-tags {
  @apply flex gap-2 mb-4;
}

.tag {
  @apply bg-blue-100 text-blue-800 px-2 py-1 rounded text-xs;
}

.memo-body {
  @apply whitespace-pre-wrap text-gray-900;
}

.attachments {
  @apply mt-6 pt-6 border-t;
}

.attachment-list {
  @apply space-y-2;
}

.attachment-item {
  @apply flex items-center gap-2;
}

.file-size {
  @apply text-sm text-gray-500;
}

.comments-section {
  @apply space-y-6;
}

.comment-form, .reply-form {
  @apply space-y-3;
}

.comment-input, .reply-input {
  @apply w-full p-3 border border-gray-300 rounded-md resize-vertical;
}

.submit-btn, .reply-btn {
  @apply px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 disabled:opacity-50;
}

.comment-item {
  @apply bg-white border rounded-lg p-4;
}

.comment-item.unread {
  @apply border-yellow-200 bg-yellow-50;
}

.comment-header, .reply-header {
  @apply flex items-center gap-4 mb-2;
}

.replies {
  @apply ml-6 mt-4 space-y-3;
}

.reply-item {
  @apply bg-gray-50 border rounded-lg p-3;
}

.reply-item.unread {
  @apply border-yellow-200 bg-yellow-100;
}
</style>
```

### Phase 4: WebSocketé€šçŸ¥çµ±åˆ

#### 4.1 é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ  Composable

```typescript
// composables/useNotifications.ts
export const useNotifications = () => {
  const config = useRuntimeConfig();
  const { staff } = useJwtAuth();
  
  const ws = ref<WebSocket | null>(null);
  const isConnected = ref(false);
  const unreadCount = ref(0);
  const notifications = ref([]);
  
  // WebSocketæ¥ç¶š
  const connect = (onNotification?: (notification: any) => void) => {
    if (!process.client || !staff.value?.id) return;
    
    try {
      const wsUrl = `${config.public.hotelCommonWsUrl}/ws/memo-notifications`;
      ws.value = new WebSocket(wsUrl);
      
      ws.value.onopen = () => {
        console.log('âœ… WebSocket connected to hotel-common');
        isConnected.value = true;
        
        // èªè¨¼ãƒ»è³¼èª­
        ws.value?.send(JSON.stringify({
          type: 'subscribe',
          sourceSystem: 'saas',
          tenantId: staff.value.tenantId,
          staffId: staff.value.id,
          token: useCookie('auth-token').value
        }));
      };
      
      ws.value.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          
          if (data.type === 'unread_count_changed') {
            unreadCount.value = data.payload.totalUnread;
            
            // ãƒ–ãƒ©ã‚¦ã‚¶é€šçŸ¥
            if (Notification.permission === 'granted') {
              new Notification('æ–°ã—ã„ãƒ¡ãƒ¢é€šçŸ¥', {
                body: `æœªèª­ãƒ¡ãƒ¢ãŒ${data.payload.totalUnread}ä»¶ã‚ã‚Šã¾ã™`,
                icon: '/favicon.ico'
              });
            }
          }
          
          // ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ³ãƒ‰ãƒ©ãƒ¼å‘¼ã³å‡ºã—
          if (onNotification) {
            onNotification(data);
          }
          
        } catch (error) {
          console.error('Failed to parse WebSocket message:', error);
        }
      };
      
      ws.value.onerror = (error) => {
        console.error('WebSocket error:', error);
        isConnected.value = false;
      };
      
      ws.value.onclose = () => {
        console.log('WebSocket disconnected');
        isConnected.value = false;
        
        // è‡ªå‹•å†æ¥ç¶šï¼ˆ5ç§’å¾Œï¼‰
        setTimeout(() => {
          if (staff.value?.id) {
            connect(onNotification);
          }
        }, 5000);
      };
      
    } catch (error) {
      console.error('Failed to connect WebSocket:', error);
      throw new Error(`WebSocketæ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
    }
  };
  
  // æ¥ç¶šçµ‚äº†
  const disconnect = () => {
    if (ws.value) {
      ws.value.close();
      ws.value = null;
      isConnected.value = false;
    }
  };
  
  // ãƒ–ãƒ©ã‚¦ã‚¶é€šçŸ¥è¨±å¯è¦æ±‚
  const requestNotificationPermission = async () => {
    if (!process.client || !('Notification' in window)) return false;
    
    if (Notification.permission === 'granted') return true;
    
    if (Notification.permission === 'denied') return false;
    
    const permission = await Notification.requestPermission();
    return permission === 'granted';
  };
  
  return {
    connect,
    disconnect,
    requestNotificationPermission,
    isConnected: readonly(isConnected),
    unreadCount: readonly(unreadCount),
    notifications: readonly(notifications)
  };
};
```

### Phase 5: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ»ç›£è¦–

#### 5.1 ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

```typescript
// utils/errorHandler.ts
export class MemoApiError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number,
    public details?: any
  ) {
    super(message);
    this.name = 'MemoApiError';
  }
}

export const handleMemoApiError = (error: any): MemoApiError => {
  // hotel-common APIã‚¨ãƒ©ãƒ¼ã®å ´åˆ
  if (error.response?.data?.error) {
    const apiError = error.response.data.error;
    return new MemoApiError(
      apiError.message,
      apiError.code,
      error.response.status,
      apiError.details
    );
  }
  
  // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã®å ´åˆ
  if (error.code === 'NETWORK_ERROR') {
    return new MemoApiError(
      'hotel-commonã¨ã®é€šä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
      'NETWORK_ERROR',
      0
    );
  }
  
  // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚¨ãƒ©ãƒ¼ã®å ´åˆ
  if (error.code === 'TIMEOUT') {
    return new MemoApiError(
      'hotel-commonã‹ã‚‰ã®å¿œç­”ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚',
      'TIMEOUT',
      0
    );
  }
  
  // ãã®ä»–ã®ã‚¨ãƒ©ãƒ¼
  return new MemoApiError(
    error.message || 'äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ',
    'UNKNOWN_ERROR',
    0
  );
};
```

#### 5.2 ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–

```typescript
// composables/useSystemMonitoring.ts
export const useSystemMonitoring = () => {
  const healthStatus = ref({
    hotelCommon: 'unknown',
    lastCheck: null,
    responseTime: 0
  });
  
  // hotel-common ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
  const checkHotelCommonHealth = async () => {
    const startTime = Date.now();
    
    try {
      const config = useRuntimeConfig();
      const response = await fetch(`${config.public.hotelCommonApiUrl}/health`, {
        method: 'GET',
        timeout: 5000
      });
      
      const endTime = Date.now();
      
      if (response.ok) {
        healthStatus.value = {
          hotelCommon: 'healthy',
          lastCheck: new Date().toISOString(),
          responseTime: endTime - startTime
        };
      } else {
        throw new Error(`Health check failed: ${response.status}`);
      }
      
    } catch (error) {
      console.error('hotel-common health check failed:', error);
      healthStatus.value = {
        hotelCommon: 'unhealthy',
        lastCheck: new Date().toISOString(),
        responseTime: Date.now() - startTime
      };
      
      throw new Error(`hotel-common is not available: ${error.message}`);
    }
  };
  
  // å®šæœŸãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯é–‹å§‹
  const startHealthMonitoring = () => {
    // åˆå›ãƒã‚§ãƒƒã‚¯
    checkHotelCommonHealth().catch(() => {
      // ã‚¨ãƒ©ãƒ¼ã¯æ—¢ã«ãƒ­ã‚°å‡ºåŠ›æ¸ˆã¿
    });
    
    // 30ç§’é–“éš”ã§ãƒã‚§ãƒƒã‚¯
    setInterval(() => {
      checkHotelCommonHealth().catch(() => {
        // ã‚¨ãƒ©ãƒ¼ã¯æ—¢ã«ãƒ­ã‚°å‡ºåŠ›æ¸ˆã¿
      });
    }, 30000);
  };
  
  return {
    healthStatus: readonly(healthStatus),
    checkHotelCommonHealth,
    startHealthMonitoring
  };
};
```

## ğŸ§ª ãƒ†ã‚¹ãƒˆå®Ÿè£…

### çµ±åˆãƒ†ã‚¹ãƒˆ

```typescript
// tests/integration/memo-common-integration.test.ts
import { describe, test, expect, beforeAll, afterAll } from 'vitest';

describe('Memo Common Integration Tests', () => {
  beforeAll(async () => {
    // hotel-common ãŒèµ·å‹•ã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
    await checkHotelCommonConnection();
  });
  
  test('ãƒ¡ãƒ¢ä¸€è¦§å–å¾—ãŒæ­£å¸¸ã«å‹•ä½œã™ã‚‹', async () => {
    const { fetchMemos } = useMemoApi();
    
    const result = await fetchMemos({
      page: 1,
      pageSize: 10
    });
    
    expect(result).toBeDefined();
    expect(result.memos).toBeInstanceOf(Array);
    expect(result.pagination).toBeDefined();
  });
  
  test('ãƒ¡ãƒ¢ä½œæˆâ†’å–å¾—â†’å‰Šé™¤ã®ãƒ•ãƒ­ãƒ¼ãŒæ­£å¸¸ã«å‹•ä½œã™ã‚‹', async () => {
    const { createMemo, fetchMemoDetail, deleteMemo } = useMemoApi();
    
    // ãƒ¡ãƒ¢ä½œæˆ
    const createResult = await createMemo({
      title: 'ãƒ†ã‚¹ãƒˆãƒ¡ãƒ¢',
      content: 'ãƒ†ã‚¹ãƒˆå†…å®¹',
      priority: 'medium'
    });
    
    expect(createResult.memo.id).toBeDefined();
    const memoId = createResult.memo.id;
    
    // ãƒ¡ãƒ¢å–å¾—
    const fetchResult = await fetchMemoDetail(memoId);
    expect(fetchResult.memo.title).toBe('ãƒ†ã‚¹ãƒˆãƒ¡ãƒ¢');
    expect(fetchResult.memo.content).toBe('ãƒ†ã‚¹ãƒˆå†…å®¹');
    
    // ãƒ¡ãƒ¢å‰Šé™¤
    await deleteMemo(memoId);
    
    // å‰Šé™¤ç¢ºèª
    await expect(fetchMemoDetail(memoId)).rejects.toThrow('MEMO_NOT_FOUND');
  });
  
  test('æ—¢èª­å‡¦ç†ãŒæ­£å¸¸ã«å‹•ä½œã™ã‚‹', async () => {
    const { createMemo, deleteMemo } = useMemoApi();
    const { markAsRead, getUnreadCount } = useReadStatus();
    
    // ãƒ†ã‚¹ãƒˆãƒ¡ãƒ¢ä½œæˆ
    const createResult = await createMemo({
      title: 'ãƒ†ã‚¹ãƒˆãƒ¡ãƒ¢ï¼ˆæ—¢èª­ãƒ†ã‚¹ãƒˆï¼‰',
      content: 'ãƒ†ã‚¹ãƒˆå†…å®¹'
    });
    const memoId = createResult.memo.id;
    
    // æ—¢èª­å‡¦ç†
    await markAsRead('memo', memoId);
    
    // æœªèª­æ•°ç¢ºèª
    const unreadResult = await getUnreadCount();
    expect(unreadResult.totalUnread).toBeGreaterThanOrEqual(0);
    
    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    await deleteMemo(memoId);
  });
});
```

## ğŸ“‹ ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆãƒ»é‹ç”¨

### ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆæ‰‹é †

1. **hotel-common ã®èµ·å‹•ç¢ºèª**
2. **ç’°å¢ƒå¤‰æ•°è¨­å®š**
3. **ä¾å­˜é–¢ä¿‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«**
4. **ãƒ“ãƒ«ãƒ‰ãƒ»ãƒ‡ãƒ—ãƒ­ã‚¤**
5. **å‹•ä½œç¢ºèª**

### ç›£è¦–é …ç›®

- hotel-common APIæ¥ç¶šçŠ¶æ³
- WebSocketæ¥ç¶šçŠ¶æ³
- ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿç‡
- ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“

---

**ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°å±¥æ­´**:
- 2025å¹´9æœˆ16æ—¥: åˆç‰ˆä½œæˆ - hotel-saasçµ±åˆã‚¬ã‚¤ãƒ‰ (kaneko)
