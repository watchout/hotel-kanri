# 統一認証システム設計書

> 更新履歴 (2025-09-08, hotel-common 統合管理による更新)
> - SSRでのCookie検証を明記（未認証描画を避ける）
> - ミドルウェア順序の明確化（認証→権限→プラン）
> - エラーマップ統一（401/403/419）と再発行ポリシー

**最終更新**: 2025年9月8日 - Cookie/SSR/クレーム・エラーマップの最終決定を反映
**変更履歴**:
- 2025年8月18日: 統一認証ミドルウェア実装完了、古い複数ミドルウェア方式を廃止
- 初版作成日: 設計段階

---

## 🎯 **実装完了ステータス**

**✅ 実装完了項目**:
- 統一認証ミドルウェア (`server/middleware/00.unified-auth.ts`)
- 権限設定ファイル (`server/config/permissions.ts`)
- 認証サービス統合 (`server/utils/authService.ts`)
- 古いミドルウェアの無効化

**🔄 進行中項目**:
- データベーステーブル作成 (common側対応中)

---

## 1. ~~現状の問題点~~ → **解決済み問題点**

<!--
**注意**: 以下の問題点は2025年8月18日の統一認証システム実装により解決済みです。
参考として残していますが、現在は該当しません。
-->

~~現在の認証システムには以下の問題があります：~~

<!--
1. **複数の認証方法が混在** → **解決済み**: 単一の統一認証ミドルウェアに統合
   - ~~`useAuth` (Nuxt Auth)~~
   - ~~`useJwtAuth` (カスタムJWT認証)~~
   - ~~API個別の認証チェック (`verifyAuth`, `checkAdminAuth`)~~

2. **環境による条件分岐** → **解決済み**: 環境非依存の一貫した認証フロー
   - ~~開発環境では認証をスキップする条件分岐が多数存在~~
   - ~~本番環境と開発環境で異なる動作~~

3. **認証ミドルウェアの不整合** → **解決済み**: 単一ミドルウェアで一元管理
   - ~~ミドルウェアで特定のパスを認証から除外~~
   - ~~APIエンドポイント側でも認証チェックが重複~~

4. **環境変数の管理問題** → **解決済み**: 統合データベース接続完了
   - ~~`DATABASE_URL`などの必須環境変数が設定されていない~~
-->

現在の認証システムには以下の問題があります：

1. **複数の認証方法が混在**
   - `useAuth` (Nuxt Auth)
   - `useJwtAuth` (カスタムJWT認証)
   - API個別の認証チェック (`verifyAuth`, `checkAdminAuth`)

2. **環境による条件分岐**
   - 開発環境では認証をスキップする条件分岐が多数存在
   - 本番環境と開発環境で異なる動作

3. **認証ミドルウェアの不整合**
   - ミドルウェアで特定のパスを認証から除外
   - APIエンドポイント側でも認証チェックが重複

4. **環境変数の管理問題**
   - `DATABASE_URL`などの必須環境変数が設定されていない

## 2. **現在の統一認証システム** (2025年8月18日実装完了)

### 2.1 実装済み基本方針

1. **✅ 単一の認証システム**
   - JWT認証に統一完了
   - サーバー側は統一認証ミドルウェア (`00.unified-auth.ts`) を使用
   - 古い複数ミドルウェア方式を廃止

2. **✅ 環境非依存の一貫した動作**
   - 開発環境と本番環境で同じ認証フロー
   - 統合データベース (`hotel_unified_db`) 接続
   - テスト用アカウント提供済み

3. **✅ 明確な権限管理**
   - 権限設定ファイル (`server/config/permissions.ts`) で一元管理
   - APIごとに必要な認証タイプを明示
   - 4つの認証タイプ: NONE, DEVICE, STAFF, ADMIN

### 2.2 **実装済み認証フロー（最終）**

```
✅ 実装完了フロー:

1. ログイン
   ユーザー → ログインフォーム → /api/v1/auth/login → JWTトークン発行

2. トークン保存（更新）
   - Cookie (httpOnly+Secure+SameSite=strict) に `access_token`/`refresh_token`
   - SSR/CSR 共通で参照。Authorization ヘッダーはサーバ間のみ使用
   - localStorage 併用は不可（移行完了後に廃止）

3. 統一認証チェック
   各リクエスト → 00.unified-auth.ts → 権限設定確認 → 認証実行

4. アクセス制御
   認証成功 → event.context.user設定 → リソースアクセス
```

### 2.3 **実装済みアーキテクチャ**

```
📁 server/
├── middleware/
│   ├── 00.unified-auth.ts          ✅ 統一認証ミドルウェア (実装完了)
│   ├── auth.ts.bak                 🚫 旧認証ミドルウェア (無効化済み)
│   ├── authDevice.ts.bak           🚫 旧デバイス認証 (無効化済み)
│   ├── unified-auth.ts.bak         🚫 旧統一認証 (無効化済み)
│   └── permission-check.ts.bak     🚫 旧権限チェック (無効化済み)
├── config/
│   └── permissions.ts              ✅ 権限設定ファイル (実装完了)
└── utils/
    └── authService.ts              ✅ 認証サービス (実装完了)
```

### 2.3 コンポーネント設計

#### 2.3.1 クライアント側

1. **AuthModule**
   - `useAuth` コンポーザブル（統一版）
   - 状態管理: トークン、ユーザー情報、認証状態
   - メソッド: ログイン、ログアウト、トークン検証

2. **AuthGuard**（順序統一）
   - 認証 → 権限 → プラン制限
   - 401（未認証）/403（権限不足・TENANT_MISMATCH）/419（期限切れ）の使い分け
   - ループ防止（クエリ `auth_retry` チェック）

#### 2.3.2 サーバー側

1. **AuthMiddleware**
   - すべてのリクエストに対する認証チェック
   - パブリックルートの明示的な定義
   - トークン検証と権限チェック

2. **AuthService**
   - ユーザー認証ロジック
   - トークン生成・検証
   - ユーザー情報取得

3. **RoleService**
   - 権限管理
   - ロールベースのアクセス制御
   - リソースごとの権限設定

### 2.4 データモデル（最終）

```typescript
// ユーザーモデル
interface User {
  id: string;
  email: string;
  tenantId: string;
  role: 'admin' | 'staff' | 'user';
  permissions: string[];
}

// トークンペイロード
interface TokenPayload {
  // Registered
  iss: string; aud: string; sub: string; exp: number; iat: number; nbf?: number; jti: string; kid?: string;
  // Custom (namespaced)
  'omotenasu:tenant_id': string;
  'omotenasu:role': string;
  'omotenasu:permissions': string[];
  'omotenasu:accessible_tenants': string[]; // 必須。tenant_id を含める
  'omotenasu:system_source': 'saas' | 'member' | 'pms';
}

// 認証レスポンス
interface AuthResponse {
  success: boolean;
  accessToken?: string;
  user?: User;
  error?: string;
}
```

## 3. 実装計画

### 3.1 統一認証サービスの実装

1. **AuthService**
   - JWT生成・検証ロジックの統一
   - ユーザー情報取得の統一
   - 環境変数の適切な管理

2. **認証ミドルウェアの統一**
   - すべてのAPIに対する一貫した認証チェック
   - パブリックルートの明示的な定義
   - エラーハンドリングの統一

### 3.2 クライアント側の統一

1. **useAuth コンポーザブルの統一**
   - 既存の `useJwtAuth` と `useAuth` を統合
   - 状態管理の一元化
   - ログイン・ログアウトフローの統一

2. **ルートガードの統一**
   - 認証状態に基づくリダイレクト
   - 権限に基づくアクセス制御
   - エラーハンドリング

### 3.3 環境変数の管理

1. **環境変数の明確化**
   - 必須環境変数のリスト作成
   - `.env.example` の提供
   - 環境変数チェックスクリプトの改善

2. **開発環境の設定**
   - 開発用データベース設定
   - 開発用認証設定
   - テスト用アカウント

## 4. テスト計画

1. **単体テスト**
   - AuthService
   - 認証ミドルウェア
   - useAuth コンポーザブル

2. **統合テスト**
   - ログインフロー
   - 保護されたAPIへのアクセス
   - 権限に基づくアクセス制御

3. **エンドツーエンドテスト**
   - ログイン・ログアウト
   - 保護されたページへのアクセス
   - 認証エラーハンドリング

## 5. 移行計画

### 5.1 段階的移行

1. **準備段階**
   - 新しい認証サービスの実装
   - 環境変数の設定
   - テスト環境の準備

2. **並行運用段階**
   - 新しい認証システムを段階的に導入
   - 既存の認証システムと並行運用
   - 問題点の洗い出しと修正

3. **完全移行段階**
   - すべてのAPIを新しい認証システムに移行
   - 古い認証コードの削除
   - 最終テストと検証

### 5.2 リスク管理

1. **互換性の問題**
   - 既存のトークンとの互換性
   - ユーザーセッションの維持

2. **パフォーマンスの問題**
   - 認証チェックのオーバーヘッド
   - データベースアクセスの最適化

3. **セキュリティの問題**
   - トークンの安全な管理
   - 権限の適切な設定

## 6. 結論

統一された認証システムを実装することで、以下のメリットが得られます：

1. **コードの一貫性と保守性の向上**
   - 重複コードの削減
   - 認証ロジックの集中管理

2. **セキュリティの向上**
   - 一貫した認証チェック
   - 適切な権限管理

3. **開発効率の向上**
   - 明確な認証フロー
   - 環境による条件分岐の削減

4. **ユーザー体験の向上**
   - 一貫したログイン体験
   - 適切なエラーハンドリング

この設計書に基づいて実装を進めることで、現在の認証問題を根本的に解決し、より堅牢で保守性の高い認証システムを構築することができます。
