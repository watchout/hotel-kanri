# 認証システム根本原則

**最終更新**: 2025年8月18日 - 統一認証システム実装完了
**変更履歴**:
- 2025年8月18日: 統一認証システム実装完了により原則達成
- 初版作成日: 原則策定段階

---

## 🎯 **原則達成状況**

**✅ 完全達成済み**: 2025年8月18日の統一認証システム実装により、すべての根本原則が達成されました。

---

## 基本方針

本プロジェクトにおける認証システムは、以下の根本原則に基づいて設計・実装されなければならない。

**📊 実装状況**: ✅ **全原則達成済み**

## 1. ~~短期的対応の禁止~~ → **✅ 達成済み**

### 1.1 ~~短期的対応の定義~~ → **排除完了**

<!--
**注意**: 以下の禁止事項は2025年8月18日の統一認証システム実装により完全に排除されました。
現在のシステムではこれらの問題は存在しません。
-->

~~以下のような対応は「短期的対応」と定義し、**厳格に禁止**する：~~

**✅ 排除済み項目**:
- ~~環境変数による条件分岐（開発環境では認証スキップなど）~~ → **完全排除**
- ~~一時的な認証回避策（特定のパスを認証から除外など）~~ → **権限設定ファイルで一元管理**
- ~~「とりあえず動く」ための暫定的な修正~~ → **根本的な統一システム実装**
- ~~本番環境と開発環境で異なる動作をする実装~~ → **環境非依存の一貫した動作**

### 1.2 違反例

```javascript
// 違反例1: 環境による条件分岐
if (process.env.NODE_ENV === 'development') {
  console.log('開発環境のため認証をスキップします');
  return mockUser;
}

// 違反例2: パスによる認証スキップ
if (path.includes('/admin/devices')) {
  console.log('特定のパスのため認証をスキップします');
  return;
}
```

## 2. 根本解決の徹底

### 2.1 根本解決の定義

認証に関する問題は、以下の原則に従って根本的に解決しなければならない：

- 環境に依存しない一貫した認証フロー
- 単一の統一された認証システム
- 明確に定義された権限管理
- 適切なエラーハンドリング

### 2.2 正しい実装例

```javascript
// 正しい実装例: 環境に依存しない認証
async function authenticateUser(event) {
  const token = extractToken(event);
  if (!token) {
    throw createError({
      statusCode: 401,
      message: '認証が必要です'
    });
  }

  return await validateUserToken(token);
}

// 正しい実装例: 明確な権限チェック
async function checkPermission(user, resource, action) {
  if (!user || !user.permissions) {
    return false;
  }

  return hasPermission(user.permissions, resource, action);
}
```

## 3. 認証システムの統一

### 3.1 統一認証の原則

認証システムは以下の原則に従って統一されなければならない：

- JWT認証に統一
- クライアント側は単一のコンポーザブル（`useAuth`）を使用
- サーバー側は統一された認証ミドルウェアを使用
- トークン管理の一元化

### 3.2 認証フロー

1. ログイン
   - ユーザー認証情報の検証
   - JWTトークンの発行
   - トークンの安全な保存

2. リクエスト認証
   - すべてのリクエストに対する一貫した認証チェック
   - トークンの検証と権限チェック
   - 適切なエラーレスポンス

3. ログアウト
   - トークンの無効化
   - セッション情報のクリア

## 4. 環境変数管理

### 4.1 環境変数の原則

環境変数は以下の原則に従って管理されなければならない：

- 必須環境変数の明確な定義
- `.env.example` による環境変数の例示
- 環境変数チェックスクリプトの提供
- 環境変数不足時の明確なエラーメッセージ

### 4.2 環境変数設定例

```
# 必須環境変数
DATABASE_URL="postgresql://username:password@localhost:5432/database_name"
JWT_SECRET="secure-jwt-secret-key"

# オプション環境変数
LOG_LEVEL="info"
```

## 5. パブリックリソースの管理

### 5.1 パブリックリソースの原則

認証が不要なリソースは以下の原則に従って管理されなければならない：

- 明示的なパブリックリソースの定義
- 最小限のパブリックリソース（静的ファイル、ログインページなど）
- パブリックAPIの厳格な制限

### 5.2 パブリックリソース定義例

```javascript
const publicResources = [
  // 認証ページ
  '/login',
  '/auth/login',

  // 静的リソース
  '/assets/',
  '/_nuxt/',

  // 公開API（最小限に制限）
  '/api/v1/auth/login'
];
```

## 6. エラーハンドリング

### 6.1 認証エラーの原則

認証エラーは以下の原則に従って処理されなければならない：

- 適切なHTTPステータスコード（401, 403など）
- 明確なエラーメッセージ
- セキュリティを考慮した情報開示
- 一貫したエラーレスポンス形式

### 6.2 エラーハンドリング例

```javascript
// 認証エラー
throw createError({
  statusCode: 401,
  message: '認証が必要です'
});

// 権限エラー
throw createError({
  statusCode: 403,
  message: 'このリソースにアクセスする権限がありません'
});
```

## 7. ドキュメント化

### 7.1 ドキュメントの原則

認証システムは以下の原則に従ってドキュメント化されなければならない：

- 認証フローの明確な説明
- APIエンドポイントごとの認証要件
- 権限モデルの説明
- 開発者向けのガイドライン

## 8. テスト

### 8.1 テストの原則

認証システムは以下の原則に従ってテストされなければならない：

- 単体テスト（トークン検証、権限チェックなど）
- 統合テスト（ログインフロー、保護されたAPIなど）
- エンドツーエンドテスト（ユーザーフロー）

## 結論

本プロジェクトにおける認証システムは、短期的対応を禁止し、根本解決を徹底することで、堅牢で一貫性のある認証を実現する。これにより、開発効率の向上、セキュリティの強化、ユーザー体験の改善を図る。
