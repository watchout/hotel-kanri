# ãƒ¡ãƒ¢æ©Ÿèƒ½ æ—¢èª­æœªèª­ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ä»•æ§˜æ›¸

**ä½œæˆæ—¥**: 2025å¹´9æœˆ16æ—¥  
**ä½œæˆè€…**: kaneko (hotel-kanri)  
**å¯¾è±¡ã‚·ã‚¹ãƒ†ãƒ **: hotel-saas  
**æ©Ÿèƒ½**: ãƒ¡ãƒ¢æ©Ÿèƒ½ã®æ—¢èª­æœªèª­ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¿½åŠ 

## ğŸš¨ **é‡è¦ãªå®Ÿè£…æ–¹é‡**

### **âŒ ç¦æ­¢äº‹é …ï¼ˆå³å®ˆï¼‰**

**ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ»ãƒ¢ãƒƒã‚¯ãƒ»ä¸€æ™‚å¯¾å¿œã®å…¨é¢ç¦æ­¢**
- âŒ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†ï¼ˆã‚¨ãƒ©ãƒ¼æ™‚ã®ä»£æ›¿å‡¦ç†ï¼‰
- âŒ ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã®ä½¿ç”¨
- âŒ ä¸€æ™‚çš„ãªå›é¿å®Ÿè£…
- âŒ try-catch ã§ã®ä¾‹å¤–éš è”½
- âŒ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã§ã®å•é¡Œå›é¿
- âŒ ã€Œã¨ã‚Šã‚ãˆãšå‹•ãã€å®Ÿè£…

**ç†ç”±**:
- ã‚¨ãƒ©ãƒ¼ã®éš è”½ã«ã‚ˆã‚Šå•é¡Œç™ºè¦‹ãŒå›°é›£
- ä¸€æ™‚å¯¾å¿œã®æ’ä¹…åŒ–ã«ã‚ˆã‚‹æŠ€è¡“çš„è² å‚µ
- ã‚·ã‚¹ãƒ†ãƒ æ•´åˆæ€§ã®ç ´ç¶»
- ãƒ‡ãƒãƒƒã‚°å›°é›£åŒ–

### **âœ… å¿…é ˆäº‹é …**

**æ­£é¢ã‹ã‚‰ã®å•é¡Œè§£æ±º**
- âœ… ã‚¨ãƒ©ãƒ¼ã¯å¿…ãšè¡¨é¢åŒ–ã•ã›ã‚‹
- âœ… å•é¡Œã®æ ¹æœ¬åŸå› ã‚’ç‰¹å®šãƒ»è§£æ±º
- âœ… é©åˆ‡ãªã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼ˆéš è”½ã§ã¯ãªã„ï¼‰
- âœ… å®Ÿè£…å‰ã®ä¾å­˜é–¢ä¿‚ç¢ºèª
- âœ… æ®µéšçš„ã ãŒç¢ºå®Ÿãªå®Ÿè£…

## ğŸ“‹ æ¦‚è¦

æ—¢å­˜ã®ãƒ¡ãƒ¢æ©Ÿèƒ½ã«ã€ã‚¹ã‚¿ãƒƒãƒ•ã”ã¨ã®æ—¢èª­æœªèª­ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç®¡ç†æ©Ÿèƒ½ã‚’è¿½åŠ ã—ã¾ã™ã€‚

### å¯¾è±¡ç¯„å›²
- **ãƒ¡ãƒ¢æœ¬ä½“**: ãƒ¡ãƒ¢ã®ä½œæˆãƒ»æ›´æ–°æ™‚ã®æ—¢èª­æœªèª­ç®¡ç†
- **ã‚³ãƒ¡ãƒ³ãƒˆ**: ãƒ¡ãƒ¢ã«å¯¾ã™ã‚‹ã‚³ãƒ¡ãƒ³ãƒˆã®æ—¢èª­æœªèª­ç®¡ç†
- **ãƒ¬ã‚¹**: ã‚³ãƒ¡ãƒ³ãƒˆã«å¯¾ã™ã‚‹ãƒ¬ã‚¹ã®æ—¢èª­æœªèª­ç®¡ç†

### è¡¨ç¤ºè¦ä»¶
- æœªèª­ãŒã‚ã‚‹å ´åˆã®ã¿ã€æœªèª­ã‚¢ã‚¤ã‚³ãƒ³ã‚’è¡¨ç¤º
- æœªèª­æ•°ã®è¡¨ç¤ºï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
- ã‚¹ã‚¿ãƒƒãƒ•ã”ã¨ã®å€‹åˆ¥ç®¡ç†

## ğŸ¯ æ©Ÿèƒ½è¦ä»¶

### 1. æ—¢èª­æœªèª­ã®å¯¾è±¡

#### 1.1 ãƒ¡ãƒ¢æœ¬ä½“
```typescript
interface MemoReadStatus {
  memoId: string;
  staffId: string;
  isRead: boolean;
  readAt: Date | null;
  lastContentUpdate: Date; // ãƒ¡ãƒ¢å†…å®¹ã®æœ€çµ‚æ›´æ–°æ—¥æ™‚
}
```

#### 1.2 ã‚³ãƒ¡ãƒ³ãƒˆ
```typescript
interface CommentReadStatus {
  commentId: string;
  staffId: string;
  isRead: boolean;
  readAt: Date | null;
}
```

#### 1.3 ãƒ¬ã‚¹ï¼ˆã‚³ãƒ¡ãƒ³ãƒˆã¸ã®è¿”ä¿¡ï¼‰
```typescript
interface ReplyReadStatus {
  replyId: string;
  staffId: string;
  isRead: boolean;
  readAt: Date | null;
}
```

### 2. æ—¢èª­æœªèª­ã®åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯

#### 2.1 ãƒ¡ãƒ¢æœ¬ä½“ã®æœªèª­åˆ¤å®š
```typescript
const isMemoUnread = (memo: Memo, staff: Staff): boolean => {
  const readStatus = memo.readStatuses.find(rs => rs.staffId === staff.id);
  
  if (!readStatus) {
    return true; // åˆå›ã¯æœªèª­
  }
  
  if (!readStatus.isRead) {
    return true; // æ˜ç¤ºçš„ã«æœªèª­
  }
  
  // ãƒ¡ãƒ¢ãŒæ›´æ–°ã•ã‚ŒãŸå ´åˆã¯æœªèª­æ‰±ã„
  return memo.updatedAt > readStatus.readAt;
};
```

#### 2.2 ã‚³ãƒ¡ãƒ³ãƒˆãƒ»ãƒ¬ã‚¹ã®æœªèª­åˆ¤å®š
```typescript
const hasUnreadComments = (memo: Memo, staff: Staff): boolean => {
  // ã‚³ãƒ¡ãƒ³ãƒˆã®æœªèª­ãƒã‚§ãƒƒã‚¯
  const unreadComments = memo.comments.filter(comment => {
    const readStatus = comment.readStatuses.find(rs => rs.staffId === staff.id);
    return !readStatus || !readStatus.isRead;
  });
  
  // ãƒ¬ã‚¹ã®æœªèª­ãƒã‚§ãƒƒã‚¯
  const unreadReplies = memo.comments.flatMap(comment => 
    comment.replies.filter(reply => {
      const readStatus = reply.readStatuses.find(rs => rs.staffId === staff.id);
      return !readStatus || !readStatus.isRead;
    })
  );
  
  return unreadComments.length > 0 || unreadReplies.length > 0;
};
```

### 3. æ—¢èª­å‡¦ç†ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°

#### 3.1 è‡ªå‹•æ—¢èª­
- ãƒ¡ãƒ¢è©³ç´°ç”»é¢ã‚’é–‹ã„ãŸæ™‚ç‚¹ã§æ—¢èª­
- ã‚³ãƒ¡ãƒ³ãƒˆãƒ»ãƒ¬ã‚¹ãŒç”»é¢ã«è¡¨ç¤ºã•ã‚ŒãŸæ™‚ç‚¹ã§æ—¢èª­

#### 3.2 æ—¢èª­å‡¦ç†ã®å®Ÿè£…
```typescript
const markAsRead = async (targetType: 'memo' | 'comment' | 'reply', targetId: string, staffId: string) => {
  // âœ… ã‚¨ãƒ©ãƒ¼ã¯éš è”½ã›ãšã€é©åˆ‡ã«å‡¦ç†
  try {
    await api.markAsRead({
      targetType,
      targetId,
      staffId,
      readAt: new Date()
    });
  } catch (error) {
    console.error(`Failed to mark ${targetType} as read:`, error);
    throw new Error(`æ—¢èª­å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
  }
};
```

## ğŸ¨ UI/UX ä»•æ§˜

### 1. æœªèª­ã‚¢ã‚¤ã‚³ãƒ³ã®è¡¨ç¤º

#### 1.1 ãƒ¡ãƒ¢ä¸€è¦§ç”»é¢
```vue
<template>
  <div class="memo-item" :class="{ 'has-unread': hasUnreadContent }">
    <div class="memo-title">
      {{ memo.title }}
      <!-- æœªèª­ã‚¢ã‚¤ã‚³ãƒ³ -->
      <span v-if="hasUnreadContent" class="unread-indicator">
        <Icon name="unread" class="text-red-500" />
        <span class="unread-count">{{ unreadCount }}</span>
      </span>
    </div>
  </div>
</template>
```

#### 1.2 ãƒ¡ãƒ¢è©³ç´°ç”»é¢
```vue
<template>
  <div class="memo-detail">
    <!-- ãƒ¡ãƒ¢æœ¬ä½“ã®æœªèª­è¡¨ç¤º -->
    <div class="memo-content" :class="{ 'unread': isMemoUnread }">
      <!-- ãƒ¡ãƒ¢å†…å®¹ -->
    </div>
    
    <!-- ã‚³ãƒ¡ãƒ³ãƒˆä¸€è¦§ -->
    <div class="comments-section">
      <div 
        v-for="comment in comments" 
        :key="comment.id"
        class="comment-item"
        :class="{ 'unread': isCommentUnread(comment) }"
      >
        <!-- ã‚³ãƒ¡ãƒ³ãƒˆå†…å®¹ -->
        
        <!-- ãƒ¬ã‚¹ä¸€è¦§ -->
        <div class="replies">
          <div 
            v-for="reply in comment.replies"
            :key="reply.id"
            class="reply-item"
            :class="{ 'unread': isReplyUnread(reply) }"
          >
            <!-- ãƒ¬ã‚¹å†…å®¹ -->
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
```

### 2. æœªèª­æ•°ã®è¨ˆç®—

```typescript
const calculateUnreadCount = (memo: Memo, staff: Staff): number => {
  let count = 0;
  
  // ãƒ¡ãƒ¢æœ¬ä½“ã®æœªèª­
  if (isMemoUnread(memo, staff)) {
    count += 1;
  }
  
  // ã‚³ãƒ¡ãƒ³ãƒˆã®æœªèª­
  memo.comments.forEach(comment => {
    if (isCommentUnread(comment, staff)) {
      count += 1;
    }
    
    // ãƒ¬ã‚¹ã®æœªèª­
    comment.replies.forEach(reply => {
      if (isReplyUnread(reply, staff)) {
        count += 1;
      }
    });
  });
  
  return count;
};
```

## ğŸ—„ï¸ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ

### 1. æ—¢èª­ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ†ãƒ¼ãƒ–ãƒ«

```sql
-- ãƒ¡ãƒ¢æ—¢èª­ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
CREATE TABLE memo_read_statuses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  memo_id UUID NOT NULL REFERENCES memos(id) ON DELETE CASCADE,
  staff_id UUID NOT NULL REFERENCES staff(id) ON DELETE CASCADE,
  is_read BOOLEAN NOT NULL DEFAULT false,
  read_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  
  UNIQUE(memo_id, staff_id)
);

-- ã‚³ãƒ¡ãƒ³ãƒˆæ—¢èª­ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
CREATE TABLE comment_read_statuses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  comment_id UUID NOT NULL REFERENCES memo_comments(id) ON DELETE CASCADE,
  staff_id UUID NOT NULL REFERENCES staff(id) ON DELETE CASCADE,
  is_read BOOLEAN NOT NULL DEFAULT false,
  read_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  
  UNIQUE(comment_id, staff_id)
);

-- ãƒ¬ã‚¹æ—¢èª­ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
CREATE TABLE reply_read_statuses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  reply_id UUID NOT NULL REFERENCES memo_replies(id) ON DELETE CASCADE,
  staff_id UUID NOT NULL REFERENCES staff(id) ON DELETE CASCADE,
  is_read BOOLEAN NOT NULL DEFAULT false,
  read_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  
  UNIQUE(reply_id, staff_id)
);
```

### 2. ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨­è¨ˆ

```sql
-- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã®ãŸã‚ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_memo_read_statuses_staff_unread ON memo_read_statuses(staff_id) WHERE is_read = false;
CREATE INDEX idx_comment_read_statuses_staff_unread ON comment_read_statuses(staff_id) WHERE is_read = false;
CREATE INDEX idx_reply_read_statuses_staff_unread ON reply_read_statuses(staff_id) WHERE is_read = false;

-- è¤‡åˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_memo_read_statuses_memo_staff ON memo_read_statuses(memo_id, staff_id);
CREATE INDEX idx_comment_read_statuses_comment_staff ON comment_read_statuses(comment_id, staff_id);
CREATE INDEX idx_reply_read_statuses_reply_staff ON reply_read_statuses(reply_id, staff_id);
```

## ğŸ“¡ API ä»•æ§˜

### 1. æ—¢èª­å‡¦ç†API

```typescript
// POST /api/v1/memos/read-status
interface MarkAsReadRequest {
  targetType: 'memo' | 'comment' | 'reply';
  targetId: string;
  staffId: string;
}

interface MarkAsReadResponse {
  success: boolean;
  readAt: string; // ISO 8601 format
}
```

### 2. æœªèª­æ•°å–å¾—API

```typescript
// GET /api/v1/memos/unread-count?staffId={staffId}
interface UnreadCountResponse {
  totalUnread: number;
  memoUnread: number;
  commentUnread: number;
  replyUnread: number;
  details: Array<{
    memoId: string;
    memoTitle: string;
    unreadCount: number;
    hasUnreadMemo: boolean;
    hasUnreadComments: boolean;
    hasUnreadReplies: boolean;
  }>;
}
```

### 3. ãƒ¡ãƒ¢ä¸€è¦§å–å¾—APIï¼ˆæ—¢èª­æƒ…å ±ä»˜ãï¼‰

```typescript
// GET /api/v1/memos?includeReadStatus=true&staffId={staffId}
interface MemoWithReadStatus {
  id: string;
  title: string;
  content: string;
  // ... æ—¢å­˜ã®ãƒ¡ãƒ¢ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
  
  // æ—¢èª­æƒ…å ±
  readStatus: {
    isRead: boolean;
    readAt: string | null;
    hasUnreadComments: boolean;
    hasUnreadReplies: boolean;
    totalUnreadCount: number;
  };
}
```

## ğŸ”„ å®Ÿè£…ãƒ•ãƒ­ãƒ¼

### Phase 1: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æº–å‚™
1. æ—¢èª­ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ†ãƒ¼ãƒ–ãƒ«ã®ä½œæˆ
2. ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®è¨­å®š
3. æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã¨ã®æ•´åˆæ€§ç¢ºèª

### Phase 2: APIå®Ÿè£…
1. æ—¢èª­å‡¦ç†API
2. æœªèª­æ•°å–å¾—API
3. ãƒ¡ãƒ¢å–å¾—APIã®æ‹¡å¼µ

### Phase 3: ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å®Ÿè£…
1. æ—¢èª­æœªèª­çŠ¶æ…‹ç®¡ç†
2. UI ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®æ›´æ–°
3. è‡ªå‹•æ—¢èª­å‡¦ç†ã®å®Ÿè£…

### Phase 4: ãƒ†ã‚¹ãƒˆãƒ»æ¤œè¨¼
1. å˜ä½“ãƒ†ã‚¹ãƒˆ
2. çµ±åˆãƒ†ã‚¹ãƒˆ
3. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ

## ğŸ§ª ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹

### 1. æ—¢èª­æœªèª­åˆ¤å®šãƒ†ã‚¹ãƒˆ

```typescript
describe('æ—¢èª­æœªèª­åˆ¤å®š', () => {
  test('æ–°è¦ãƒ¡ãƒ¢ã¯æœªèª­ã¨ã—ã¦åˆ¤å®šã•ã‚Œã‚‹', () => {
    const memo = createMemo();
    const staff = createStaff();
    
    expect(isMemoUnread(memo, staff)).toBe(true);
  });
  
  test('æ—¢èª­å¾Œã«ãƒ¡ãƒ¢ãŒæ›´æ–°ã•ã‚ŒãŸå ´åˆã¯æœªèª­ã¨ã—ã¦åˆ¤å®šã•ã‚Œã‚‹', () => {
    const memo = createMemo();
    const staff = createStaff();
    
    // æ—¢èª­å‡¦ç†
    markMemoAsRead(memo.id, staff.id);
    
    // ãƒ¡ãƒ¢æ›´æ–°
    updateMemo(memo.id, { content: 'updated content' });
    
    expect(isMemoUnread(memo, staff)).toBe(true);
  });
});
```

### 2. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ

```typescript
describe('ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ', () => {
  test('å¤§é‡ã®ãƒ¡ãƒ¢ã§ã‚‚æœªèª­æ•°è¨ˆç®—ãŒé«˜é€Ÿã§ã‚ã‚‹', async () => {
    const memos = await createMemos(1000);
    const staff = createStaff();
    
    const startTime = Date.now();
    const unreadCount = await calculateTotalUnreadCount(staff.id);
    const endTime = Date.now();
    
    expect(endTime - startTime).toBeLessThan(100); // 100msä»¥å†…
  });
});
```

## ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è€ƒæ…®äº‹é …

### 1. ã‚¯ã‚¨ãƒªæœ€é©åŒ–

```sql
-- åŠ¹ç‡çš„ãªæœªèª­æ•°å–å¾—ã‚¯ã‚¨ãƒª
WITH unread_counts AS (
  SELECT 
    m.id as memo_id,
    m.title,
    CASE WHEN mrs.is_read = false OR mrs.is_read IS NULL THEN 1 ELSE 0 END as memo_unread,
    COALESCE(comment_unread.count, 0) as comment_unread,
    COALESCE(reply_unread.count, 0) as reply_unread
  FROM memos m
  LEFT JOIN memo_read_statuses mrs ON m.id = mrs.memo_id AND mrs.staff_id = $1
  LEFT JOIN (
    SELECT 
      mc.memo_id,
      COUNT(*) as count
    FROM memo_comments mc
    LEFT JOIN comment_read_statuses crs ON mc.id = crs.comment_id AND crs.staff_id = $1
    WHERE crs.is_read = false OR crs.is_read IS NULL
    GROUP BY mc.memo_id
  ) comment_unread ON m.id = comment_unread.memo_id
  LEFT JOIN (
    SELECT 
      mc.memo_id,
      COUNT(*) as count
    FROM memo_comments mc
    JOIN memo_replies mr ON mc.id = mr.comment_id
    LEFT JOIN reply_read_statuses rrs ON mr.id = rrs.reply_id AND rrs.staff_id = $1
    WHERE rrs.is_read = false OR rrs.is_read IS NULL
    GROUP BY mc.memo_id
  ) reply_unread ON m.id = reply_unread.memo_id
)
SELECT 
  memo_id,
  title,
  (memo_unread + comment_unread + reply_unread) as total_unread
FROM unread_counts
WHERE (memo_unread + comment_unread + reply_unread) > 0;
```

### 2. ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥

```typescript
// Redis ã‚’ä½¿ç”¨ã—ãŸæœªèª­æ•°ã‚­ãƒ£ãƒƒã‚·ãƒ¥
const getUnreadCountWithCache = async (staffId: string): Promise<number> => {
  const cacheKey = `unread_count:${staffId}`;
  
  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å–å¾—ã‚’è©¦è¡Œ
  const cached = await redis.get(cacheKey);
  if (cached !== null) {
    return parseInt(cached, 10);
  }
  
  // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰å–å¾—
  const count = await calculateUnreadCountFromDB(staffId);
  
  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜ï¼ˆ5åˆ†é–“ï¼‰
  await redis.setex(cacheKey, 300, count.toString());
  
  return count;
};
```

## ğŸš€ ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆè¨ˆç”»

### 1. æ®µéšçš„ãƒ‡ãƒ—ãƒ­ã‚¤

**Phase 1**: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒæ›´æ–°
- æ—¢èª­ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ
- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨­å®š

**Phase 2**: APIå®Ÿè£…ãƒ‡ãƒ—ãƒ­ã‚¤
- æ—¢èª­å‡¦ç†API
- æœªèª­æ•°å–å¾—API

**Phase 3**: ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰æ›´æ–°
- UI ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆæ›´æ–°
- æ—¢èª­æœªèª­è¡¨ç¤ºæ©Ÿèƒ½

### 2. ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨ˆç”»

```sql
-- ç·Šæ€¥æ™‚ã®ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨
DROP TABLE IF EXISTS reply_read_statuses;
DROP TABLE IF EXISTS comment_read_statuses;
DROP TABLE IF EXISTS memo_read_statuses;
```

## ğŸ“ é‹ç”¨ãƒ»ä¿å®ˆ

### 1. ç›£è¦–é …ç›®

- æ—¢èª­å‡¦ç†APIã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“
- æœªèª­æ•°è¨ˆç®—ã‚¯ã‚¨ãƒªã®å®Ÿè¡Œæ™‚é–“
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®å®¹é‡å¢—åŠ ç‡

### 2. å®šæœŸãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹

```sql
-- å¤ã„æ—¢èª­ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®å‰Šé™¤ï¼ˆ6ãƒ¶æœˆä»¥ä¸Šå‰ï¼‰
DELETE FROM memo_read_statuses 
WHERE read_at < NOW() - INTERVAL '6 months';

DELETE FROM comment_read_statuses 
WHERE read_at < NOW() - INTERVAL '6 months';

DELETE FROM reply_read_statuses 
WHERE read_at < NOW() - INTERVAL '6 months';
```

---

**ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°å±¥æ­´**:
- 2025å¹´9æœˆ16æ—¥: åˆç‰ˆä½œæˆ (kaneko)
